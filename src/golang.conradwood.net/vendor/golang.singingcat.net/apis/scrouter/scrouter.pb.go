// Code generated by protoc-gen-go.
// source: golang.singingcat.net/apis/scrouter/scrouter.proto
// DO NOT EDIT!

/*
Package scrouter is a generated protocol buffer package.

It is generated from these files:
	golang.singingcat.net/apis/scrouter/scrouter.proto

It has these top-level messages:
	PeerList
	Peer
	PathAndRoutes
	Path
	PathRoute
	DBPeer
	ModuleState
	NextHop
	NextHopResponse
	DBRoute
	RouteRequest
	RouteResult
	Route
	RouteUpdateFailure
	RouteUpdatePeer
	FullRoute
	PendingChangesList
	RouteList
*/
package scrouter

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"
import singingcat "golang.singingcat.net/apis/singingcat"
import scweb "golang.singingcat.net/apis/scweb"
import scmodcomms "golang.singingcat.net/apis/scmodcomms"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type RouteErrors int32

const (
	RouteErrors_ROUTE_UNDEF            RouteErrors = 0
	RouteErrors_NO_HOSTROUTE_FOR_ROUTE RouteErrors = 101
	RouteErrors_NO_ROUTE_CONFIGURED    RouteErrors = 102
)

var RouteErrors_name = map[int32]string{
	0:   "ROUTE_UNDEF",
	101: "NO_HOSTROUTE_FOR_ROUTE",
	102: "NO_ROUTE_CONFIGURED",
}
var RouteErrors_value = map[string]int32{
	"ROUTE_UNDEF":            0,
	"NO_HOSTROUTE_FOR_ROUTE": 101,
	"NO_ROUTE_CONFIGURED":    102,
}

func (x RouteErrors) String() string {
	return proto.EnumName(RouteErrors_name, int32(x))
}
func (RouteErrors) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type RouteState int32

const (
	RouteState_REMOVED            RouteState = 0
	RouteState_APPLIED            RouteState = 1
	RouteState_TO_BE_APPLIED      RouteState = 2
	RouteState_TO_BE_REMOVED      RouteState = 3
	RouteState_NOT_CURRENTLY_USED RouteState = 4
)

var RouteState_name = map[int32]string{
	0: "REMOVED",
	1: "APPLIED",
	2: "TO_BE_APPLIED",
	3: "TO_BE_REMOVED",
	4: "NOT_CURRENTLY_USED",
}
var RouteState_value = map[string]int32{
	"REMOVED":            0,
	"APPLIED":            1,
	"TO_BE_APPLIED":      2,
	"TO_BE_REMOVED":      3,
	"NOT_CURRENTLY_USED": 4,
}

func (x RouteState) String() string {
	return proto.EnumName(RouteState_name, int32(x))
}
func (RouteState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// a list of peers
type PeerList struct {
	Peers []*Peer `protobuf:"bytes,1,rep,name=Peers" json:"Peers,omitempty"`
}

func (m *PeerList) Reset()                    { *m = PeerList{} }
func (m *PeerList) String() string            { return proto.CompactTextString(m) }
func (*PeerList) ProtoMessage()               {}
func (*PeerList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *PeerList) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

// a peer is a singingcat module in 'range' (aka a neighbour)
type Peer struct {
	Module             *singingcat.ModuleRef `protobuf:"bytes,1,opt,name=Module" json:"Module,omitempty"`
	Device             singingcat.Device     `protobuf:"varint,2,opt,name=Device,enum=singingcat.Device" json:"Device,omitempty"`
	HasCloudConnection bool                  `protobuf:"varint,3,opt,name=HasCloudConnection" json:"HasCloudConnection,omitempty"`
	SignalIndicator    uint32                `protobuf:"varint,4,opt,name=SignalIndicator" json:"SignalIndicator,omitempty"`
}

func (m *Peer) Reset()                    { *m = Peer{} }
func (m *Peer) String() string            { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()               {}
func (*Peer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Peer) GetModule() *singingcat.ModuleRef {
	if m != nil {
		return m.Module
	}
	return nil
}

func (m *Peer) GetDevice() singingcat.Device {
	if m != nil {
		return m.Device
	}
	return singingcat.Device_DEVICE_UNSPECIFIED
}

func (m *Peer) GetHasCloudConnection() bool {
	if m != nil {
		return m.HasCloudConnection
	}
	return false
}

func (m *Peer) GetSignalIndicator() uint32 {
	if m != nil {
		return m.SignalIndicator
	}
	return 0
}

type PathAndRoutes struct {
	Path   *Path        `protobuf:"bytes,1,opt,name=Path" json:"Path,omitempty"`
	Routes []*PathRoute `protobuf:"bytes,2,rep,name=Routes" json:"Routes,omitempty"`
}

func (m *PathAndRoutes) Reset()                    { *m = PathAndRoutes{} }
func (m *PathAndRoutes) String() string            { return proto.CompactTextString(m) }
func (*PathAndRoutes) ProtoMessage()               {}
func (*PathAndRoutes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *PathAndRoutes) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *PathAndRoutes) GetRoutes() []*PathRoute {
	if m != nil {
		return m.Routes
	}
	return nil
}

type Path struct {
	ID               uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	ModuleA          uint64 `protobuf:"varint,2,opt,name=ModuleA" json:"ModuleA,omitempty"`
	ModuleB          uint64 `protobuf:"varint,3,opt,name=ModuleB" json:"ModuleB,omitempty"`
	Difficulty       uint32 `protobuf:"varint,4,opt,name=Difficulty" json:"Difficulty,omitempty"`
	Disabled         bool   `protobuf:"varint,5,opt,name=Disabled" json:"Disabled,omitempty"`
	TSDisabled       uint32 `protobuf:"varint,6,opt,name=TSDisabled" json:"TSDisabled,omitempty"`
	PathKey          []byte `protobuf:"bytes,7,opt,name=PathKey,proto3" json:"PathKey,omitempty"`
	TSLastCalculated uint32 `protobuf:"varint,8,opt,name=TSLastCalculated" json:"TSLastCalculated,omitempty"`
}

func (m *Path) Reset()                    { *m = Path{} }
func (m *Path) String() string            { return proto.CompactTextString(m) }
func (*Path) ProtoMessage()               {}
func (*Path) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Path) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Path) GetModuleA() uint64 {
	if m != nil {
		return m.ModuleA
	}
	return 0
}

func (m *Path) GetModuleB() uint64 {
	if m != nil {
		return m.ModuleB
	}
	return 0
}

func (m *Path) GetDifficulty() uint32 {
	if m != nil {
		return m.Difficulty
	}
	return 0
}

func (m *Path) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func (m *Path) GetTSDisabled() uint32 {
	if m != nil {
		return m.TSDisabled
	}
	return 0
}

func (m *Path) GetPathKey() []byte {
	if m != nil {
		return m.PathKey
	}
	return nil
}

func (m *Path) GetTSLastCalculated() uint32 {
	if m != nil {
		return m.TSLastCalculated
	}
	return 0
}

type PathRoute struct {
	ID                  uint64            `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Path                *Path             `protobuf:"bytes,2,opt,name=Path" json:"Path,omitempty"`
	OnModule            uint64            `protobuf:"varint,3,opt,name=OnModule" json:"OnModule,omitempty"`
	NextHop             uint64            `protobuf:"varint,4,opt,name=NextHop" json:"NextHop,omitempty"`
	ViaDevice           singingcat.Device `protobuf:"varint,5,opt,name=ViaDevice,enum=singingcat.Device" json:"ViaDevice,omitempty"`
	RouteState          RouteState        `protobuf:"varint,6,opt,name=RouteState,enum=scrouter.RouteState" json:"RouteState,omitempty"`
	ForwardFailure      uint32            `protobuf:"varint,7,opt,name=ForwardFailure" json:"ForwardFailure,omitempty"`
	TSLastApplyAttempt  uint32            `protobuf:"varint,8,opt,name=TSLastApplyAttempt" json:"TSLastApplyAttempt,omitempty"`
	TSLastApplied       uint32            `protobuf:"varint,9,opt,name=TSLastApplied" json:"TSLastApplied,omitempty"`
	TSLastRemoveAttempt uint32            `protobuf:"varint,10,opt,name=TSLastRemoveAttempt" json:"TSLastRemoveAttempt,omitempty"`
	TSLastRemoved       uint32            `protobuf:"varint,11,opt,name=TSLastRemoved" json:"TSLastRemoved,omitempty"`
	ApplyOrder          uint32            `protobuf:"varint,12,opt,name=ApplyOrder" json:"ApplyOrder,omitempty"`
	IsReverse           bool              `protobuf:"varint,13,opt,name=IsReverse" json:"IsReverse,omitempty"`
}

func (m *PathRoute) Reset()                    { *m = PathRoute{} }
func (m *PathRoute) String() string            { return proto.CompactTextString(m) }
func (*PathRoute) ProtoMessage()               {}
func (*PathRoute) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *PathRoute) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *PathRoute) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *PathRoute) GetOnModule() uint64 {
	if m != nil {
		return m.OnModule
	}
	return 0
}

func (m *PathRoute) GetNextHop() uint64 {
	if m != nil {
		return m.NextHop
	}
	return 0
}

func (m *PathRoute) GetViaDevice() singingcat.Device {
	if m != nil {
		return m.ViaDevice
	}
	return singingcat.Device_DEVICE_UNSPECIFIED
}

func (m *PathRoute) GetRouteState() RouteState {
	if m != nil {
		return m.RouteState
	}
	return RouteState_REMOVED
}

func (m *PathRoute) GetForwardFailure() uint32 {
	if m != nil {
		return m.ForwardFailure
	}
	return 0
}

func (m *PathRoute) GetTSLastApplyAttempt() uint32 {
	if m != nil {
		return m.TSLastApplyAttempt
	}
	return 0
}

func (m *PathRoute) GetTSLastApplied() uint32 {
	if m != nil {
		return m.TSLastApplied
	}
	return 0
}

func (m *PathRoute) GetTSLastRemoveAttempt() uint32 {
	if m != nil {
		return m.TSLastRemoveAttempt
	}
	return 0
}

func (m *PathRoute) GetTSLastRemoved() uint32 {
	if m != nil {
		return m.TSLastRemoved
	}
	return 0
}

func (m *PathRoute) GetApplyOrder() uint32 {
	if m != nil {
		return m.ApplyOrder
	}
	return 0
}

func (m *PathRoute) GetIsReverse() bool {
	if m != nil {
		return m.IsReverse
	}
	return false
}

type DBPeer struct {
	ID                 uint64            `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	ModuleID           uint64            `protobuf:"varint,2,opt,name=ModuleID" json:"ModuleID,omitempty"`
	PeerModuleID       uint64            `protobuf:"varint,3,opt,name=PeerModuleID" json:"PeerModuleID,omitempty"`
	Device             singingcat.Device `protobuf:"varint,4,opt,name=Device,enum=singingcat.Device" json:"Device,omitempty"`
	HasCloudConnection bool              `protobuf:"varint,5,opt,name=HasCloudConnection" json:"HasCloudConnection,omitempty"`
	LastReported       uint32            `protobuf:"varint,6,opt,name=LastReported" json:"LastReported,omitempty"`
	SignalIndicator    uint32            `protobuf:"varint,7,opt,name=SignalIndicator" json:"SignalIndicator,omitempty"`
}

func (m *DBPeer) Reset()                    { *m = DBPeer{} }
func (m *DBPeer) String() string            { return proto.CompactTextString(m) }
func (*DBPeer) ProtoMessage()               {}
func (*DBPeer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *DBPeer) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DBPeer) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *DBPeer) GetPeerModuleID() uint64 {
	if m != nil {
		return m.PeerModuleID
	}
	return 0
}

func (m *DBPeer) GetDevice() singingcat.Device {
	if m != nil {
		return m.Device
	}
	return singingcat.Device_DEVICE_UNSPECIFIED
}

func (m *DBPeer) GetHasCloudConnection() bool {
	if m != nil {
		return m.HasCloudConnection
	}
	return false
}

func (m *DBPeer) GetLastReported() uint32 {
	if m != nil {
		return m.LastReported
	}
	return 0
}

func (m *DBPeer) GetSignalIndicator() uint32 {
	if m != nil {
		return m.SignalIndicator
	}
	return 0
}

type ModuleState struct {
	ID                   uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	ModuleID             uint64 `protobuf:"varint,2,opt,name=ModuleID" json:"ModuleID,omitempty"`
	LastPeersRequested   uint32 `protobuf:"varint,3,opt,name=LastPeersRequested" json:"LastPeersRequested,omitempty"`
	LastPeersAckReceived uint32 `protobuf:"varint,4,opt,name=LastPeersAckReceived" json:"LastPeersAckReceived,omitempty"`
	LastComSequence      uint32 `protobuf:"varint,5,opt,name=LastComSequence" json:"LastComSequence,omitempty"`
}

func (m *ModuleState) Reset()                    { *m = ModuleState{} }
func (m *ModuleState) String() string            { return proto.CompactTextString(m) }
func (*ModuleState) ProtoMessage()               {}
func (*ModuleState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ModuleState) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ModuleState) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *ModuleState) GetLastPeersRequested() uint32 {
	if m != nil {
		return m.LastPeersRequested
	}
	return 0
}

func (m *ModuleState) GetLastPeersAckReceived() uint32 {
	if m != nil {
		return m.LastPeersAckReceived
	}
	return 0
}

func (m *ModuleState) GetLastComSequence() uint32 {
	if m != nil {
		return m.LastComSequence
	}
	return 0
}

type NextHop struct {
	ID              uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	TargetModuleID  uint64 `protobuf:"varint,2,opt,name=TargetModuleID" json:"TargetModuleID,omitempty"`
	NextHopModuleID uint64 `protobuf:"varint,3,opt,name=NextHopModuleID" json:"NextHopModuleID,omitempty"`
	Created         uint32 `protobuf:"varint,4,opt,name=Created" json:"Created,omitempty"`
}

func (m *NextHop) Reset()                    { *m = NextHop{} }
func (m *NextHop) String() string            { return proto.CompactTextString(m) }
func (*NextHop) ProtoMessage()               {}
func (*NextHop) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *NextHop) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *NextHop) GetTargetModuleID() uint64 {
	if m != nil {
		return m.TargetModuleID
	}
	return 0
}

func (m *NextHop) GetNextHopModuleID() uint64 {
	if m != nil {
		return m.NextHopModuleID
	}
	return 0
}

func (m *NextHop) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

type NextHopResponse struct {
	ModuleID uint64 `protobuf:"varint,1,opt,name=ModuleID" json:"ModuleID,omitempty"`
	NodeID   uint32 `protobuf:"varint,2,opt,name=NodeID" json:"NodeID,omitempty"`
	Valid    bool   `protobuf:"varint,3,opt,name=Valid" json:"Valid,omitempty"`
}

func (m *NextHopResponse) Reset()                    { *m = NextHopResponse{} }
func (m *NextHopResponse) String() string            { return proto.CompactTextString(m) }
func (*NextHopResponse) ProtoMessage()               {}
func (*NextHopResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *NextHopResponse) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *NextHopResponse) GetNodeID() uint32 {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func (m *NextHopResponse) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

type DBRoute struct {
	ID                   uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	ModuleID             uint64 `protobuf:"varint,2,opt,name=ModuleID" json:"ModuleID,omitempty"`
	TargetMatch          uint64 `protobuf:"varint,3,opt,name=TargetMatch" json:"TargetMatch,omitempty"`
	SenderMatch          uint64 `protobuf:"varint,4,opt,name=SenderMatch" json:"SenderMatch,omitempty"`
	NextHop              uint64 `protobuf:"varint,5,opt,name=NextHop" json:"NextHop,omitempty"`
	DeviceMatch          uint32 `protobuf:"varint,6,opt,name=DeviceMatch" json:"DeviceMatch,omitempty"`
	OnDevice             uint32 `protobuf:"varint,7,opt,name=OnDevice" json:"OnDevice,omitempty"`
	LastApplied          uint32 `protobuf:"varint,8,opt,name=LastApplied" json:"LastApplied,omitempty"`
	LastApplyAttempt     uint32 `protobuf:"varint,9,opt,name=LastApplyAttempt" json:"LastApplyAttempt,omitempty"`
	ToBeDeleted          bool   `protobuf:"varint,10,opt,name=ToBeDeleted" json:"ToBeDeleted,omitempty"`
	NextHopImplicitRoute uint64 `protobuf:"varint,11,opt,name=NextHopImplicitRoute" json:"NextHopImplicitRoute,omitempty"`
	ApplyAttempts        uint64 `protobuf:"varint,12,opt,name=ApplyAttempts" json:"ApplyAttempts,omitempty"`
}

func (m *DBRoute) Reset()                    { *m = DBRoute{} }
func (m *DBRoute) String() string            { return proto.CompactTextString(m) }
func (*DBRoute) ProtoMessage()               {}
func (*DBRoute) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *DBRoute) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DBRoute) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *DBRoute) GetTargetMatch() uint64 {
	if m != nil {
		return m.TargetMatch
	}
	return 0
}

func (m *DBRoute) GetSenderMatch() uint64 {
	if m != nil {
		return m.SenderMatch
	}
	return 0
}

func (m *DBRoute) GetNextHop() uint64 {
	if m != nil {
		return m.NextHop
	}
	return 0
}

func (m *DBRoute) GetDeviceMatch() uint32 {
	if m != nil {
		return m.DeviceMatch
	}
	return 0
}

func (m *DBRoute) GetOnDevice() uint32 {
	if m != nil {
		return m.OnDevice
	}
	return 0
}

func (m *DBRoute) GetLastApplied() uint32 {
	if m != nil {
		return m.LastApplied
	}
	return 0
}

func (m *DBRoute) GetLastApplyAttempt() uint32 {
	if m != nil {
		return m.LastApplyAttempt
	}
	return 0
}

func (m *DBRoute) GetToBeDeleted() bool {
	if m != nil {
		return m.ToBeDeleted
	}
	return false
}

func (m *DBRoute) GetNextHopImplicitRoute() uint64 {
	if m != nil {
		return m.NextHopImplicitRoute
	}
	return 0
}

func (m *DBRoute) GetApplyAttempts() uint64 {
	if m != nil {
		return m.ApplyAttempts
	}
	return 0
}

type RouteRequest struct {
	Module      *singingcat.ModuleRef `protobuf:"bytes,1,opt,name=Module" json:"Module,omitempty"`
	TargetMatch *singingcat.ModuleRef `protobuf:"bytes,2,opt,name=TargetMatch" json:"TargetMatch,omitempty"`
	SenderMatch *singingcat.ModuleRef `protobuf:"bytes,3,opt,name=SenderMatch" json:"SenderMatch,omitempty"`
	NextHop     *singingcat.ModuleRef `protobuf:"bytes,4,opt,name=NextHop" json:"NextHop,omitempty"`
	DeviceMatch singingcat.Device     `protobuf:"varint,5,opt,name=DeviceMatch,enum=singingcat.Device" json:"DeviceMatch,omitempty"`
	OnDevice    singingcat.Device     `protobuf:"varint,6,opt,name=OnDevice,enum=singingcat.Device" json:"OnDevice,omitempty"`
}

func (m *RouteRequest) Reset()                    { *m = RouteRequest{} }
func (m *RouteRequest) String() string            { return proto.CompactTextString(m) }
func (*RouteRequest) ProtoMessage()               {}
func (*RouteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *RouteRequest) GetModule() *singingcat.ModuleRef {
	if m != nil {
		return m.Module
	}
	return nil
}

func (m *RouteRequest) GetTargetMatch() *singingcat.ModuleRef {
	if m != nil {
		return m.TargetMatch
	}
	return nil
}

func (m *RouteRequest) GetSenderMatch() *singingcat.ModuleRef {
	if m != nil {
		return m.SenderMatch
	}
	return nil
}

func (m *RouteRequest) GetNextHop() *singingcat.ModuleRef {
	if m != nil {
		return m.NextHop
	}
	return nil
}

func (m *RouteRequest) GetDeviceMatch() singingcat.Device {
	if m != nil {
		return m.DeviceMatch
	}
	return singingcat.Device_DEVICE_UNSPECIFIED
}

func (m *RouteRequest) GetOnDevice() singingcat.Device {
	if m != nil {
		return m.OnDevice
	}
	return singingcat.Device_DEVICE_UNSPECIFIED
}

type RouteResult struct {
	NextHop      *NextHopResponse `protobuf:"bytes,1,opt,name=NextHop" json:"NextHop,omitempty"`
	Success      bool             `protobuf:"varint,2,opt,name=Success" json:"Success,omitempty"`
	Milliseconds uint64           `protobuf:"varint,3,opt,name=Milliseconds" json:"Milliseconds,omitempty"`
}

func (m *RouteResult) Reset()                    { *m = RouteResult{} }
func (m *RouteResult) String() string            { return proto.CompactTextString(m) }
func (*RouteResult) ProtoMessage()               {}
func (*RouteResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *RouteResult) GetNextHop() *NextHopResponse {
	if m != nil {
		return m.NextHop
	}
	return nil
}

func (m *RouteResult) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *RouteResult) GetMilliseconds() uint64 {
	if m != nil {
		return m.Milliseconds
	}
	return 0
}

type Route struct {
	HostModuleID uint64 `protobuf:"varint,1,opt,name=HostModuleID" json:"HostModuleID,omitempty"`
	NextModuleID uint64 `protobuf:"varint,2,opt,name=NextModuleID" json:"NextModuleID,omitempty"`
}

func (m *Route) Reset()                    { *m = Route{} }
func (m *Route) String() string            { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()               {}
func (*Route) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Route) GetHostModuleID() uint64 {
	if m != nil {
		return m.HostModuleID
	}
	return 0
}

func (m *Route) GetNextModuleID() uint64 {
	if m != nil {
		return m.NextModuleID
	}
	return 0
}

type RouteUpdateFailure struct {
	Sender          *scweb.Module `protobuf:"bytes,1,opt,name=Sender" json:"Sender,omitempty"`
	ForwardingError uint32        `protobuf:"varint,2,opt,name=ForwardingError" json:"ForwardingError,omitempty"`
	RecipientNode   uint32        `protobuf:"varint,3,opt,name=RecipientNode" json:"RecipientNode,omitempty"`
	RecipientModule *scweb.Module `protobuf:"bytes,4,opt,name=RecipientModule" json:"RecipientModule,omitempty"`
	TargetNode      uint32        `protobuf:"varint,5,opt,name=TargetNode" json:"TargetNode,omitempty"`
	TargetModule    *scweb.Module `protobuf:"bytes,6,opt,name=TargetModule" json:"TargetModule,omitempty"`
	Sequence        uint32        `protobuf:"varint,7,opt,name=Sequence" json:"Sequence,omitempty"`
}

func (m *RouteUpdateFailure) Reset()                    { *m = RouteUpdateFailure{} }
func (m *RouteUpdateFailure) String() string            { return proto.CompactTextString(m) }
func (*RouteUpdateFailure) ProtoMessage()               {}
func (*RouteUpdateFailure) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *RouteUpdateFailure) GetSender() *scweb.Module {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *RouteUpdateFailure) GetForwardingError() uint32 {
	if m != nil {
		return m.ForwardingError
	}
	return 0
}

func (m *RouteUpdateFailure) GetRecipientNode() uint32 {
	if m != nil {
		return m.RecipientNode
	}
	return 0
}

func (m *RouteUpdateFailure) GetRecipientModule() *scweb.Module {
	if m != nil {
		return m.RecipientModule
	}
	return nil
}

func (m *RouteUpdateFailure) GetTargetNode() uint32 {
	if m != nil {
		return m.TargetNode
	}
	return 0
}

func (m *RouteUpdateFailure) GetTargetModule() *scweb.Module {
	if m != nil {
		return m.TargetModule
	}
	return nil
}

func (m *RouteUpdateFailure) GetSequence() uint32 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

type RouteUpdatePeer struct {
	Sender          *scweb.Module     `protobuf:"bytes,1,opt,name=Sender" json:"Sender,omitempty"`
	Device          singingcat.Device `protobuf:"varint,2,opt,name=Device,enum=singingcat.Device" json:"Device,omitempty"`
	Peer            *scweb.Module     `protobuf:"bytes,3,opt,name=Peer" json:"Peer,omitempty"`
	Added           bool              `protobuf:"varint,4,opt,name=Added" json:"Added,omitempty"`
	SignalIndicator uint32            `protobuf:"varint,5,opt,name=SignalIndicator" json:"SignalIndicator,omitempty"`
}

func (m *RouteUpdatePeer) Reset()                    { *m = RouteUpdatePeer{} }
func (m *RouteUpdatePeer) String() string            { return proto.CompactTextString(m) }
func (*RouteUpdatePeer) ProtoMessage()               {}
func (*RouteUpdatePeer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *RouteUpdatePeer) GetSender() *scweb.Module {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *RouteUpdatePeer) GetDevice() singingcat.Device {
	if m != nil {
		return m.Device
	}
	return singingcat.Device_DEVICE_UNSPECIFIED
}

func (m *RouteUpdatePeer) GetPeer() *scweb.Module {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *RouteUpdatePeer) GetAdded() bool {
	if m != nil {
		return m.Added
	}
	return false
}

func (m *RouteUpdatePeer) GetSignalIndicator() uint32 {
	if m != nil {
		return m.SignalIndicator
	}
	return 0
}

type FullRoute struct {
	Routes []*DBRoute `protobuf:"bytes,1,rep,name=Routes" json:"Routes,omitempty"`
}

func (m *FullRoute) Reset()                    { *m = FullRoute{} }
func (m *FullRoute) String() string            { return proto.CompactTextString(m) }
func (*FullRoute) ProtoMessage()               {}
func (*FullRoute) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *FullRoute) GetRoutes() []*DBRoute {
	if m != nil {
		return m.Routes
	}
	return nil
}

type PendingChangesList struct {
	Routes []*DBRoute `protobuf:"bytes,1,rep,name=Routes" json:"Routes,omitempty"`
}

func (m *PendingChangesList) Reset()                    { *m = PendingChangesList{} }
func (m *PendingChangesList) String() string            { return proto.CompactTextString(m) }
func (*PendingChangesList) ProtoMessage()               {}
func (*PendingChangesList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *PendingChangesList) GetRoutes() []*DBRoute {
	if m != nil {
		return m.Routes
	}
	return nil
}

type RouteList struct {
	Routes []*DBRoute `protobuf:"bytes,1,rep,name=Routes" json:"Routes,omitempty"`
}

func (m *RouteList) Reset()                    { *m = RouteList{} }
func (m *RouteList) String() string            { return proto.CompactTextString(m) }
func (*RouteList) ProtoMessage()               {}
func (*RouteList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *RouteList) GetRoutes() []*DBRoute {
	if m != nil {
		return m.Routes
	}
	return nil
}

func init() {
	proto.RegisterType((*PeerList)(nil), "scrouter.PeerList")
	proto.RegisterType((*Peer)(nil), "scrouter.Peer")
	proto.RegisterType((*PathAndRoutes)(nil), "scrouter.PathAndRoutes")
	proto.RegisterType((*Path)(nil), "scrouter.Path")
	proto.RegisterType((*PathRoute)(nil), "scrouter.PathRoute")
	proto.RegisterType((*DBPeer)(nil), "scrouter.DBPeer")
	proto.RegisterType((*ModuleState)(nil), "scrouter.ModuleState")
	proto.RegisterType((*NextHop)(nil), "scrouter.NextHop")
	proto.RegisterType((*NextHopResponse)(nil), "scrouter.NextHopResponse")
	proto.RegisterType((*DBRoute)(nil), "scrouter.DBRoute")
	proto.RegisterType((*RouteRequest)(nil), "scrouter.RouteRequest")
	proto.RegisterType((*RouteResult)(nil), "scrouter.RouteResult")
	proto.RegisterType((*Route)(nil), "scrouter.Route")
	proto.RegisterType((*RouteUpdateFailure)(nil), "scrouter.RouteUpdateFailure")
	proto.RegisterType((*RouteUpdatePeer)(nil), "scrouter.RouteUpdatePeer")
	proto.RegisterType((*FullRoute)(nil), "scrouter.FullRoute")
	proto.RegisterType((*PendingChangesList)(nil), "scrouter.PendingChangesList")
	proto.RegisterType((*RouteList)(nil), "scrouter.RouteList")
	proto.RegisterEnum("scrouter.RouteErrors", RouteErrors_name, RouteErrors_value)
	proto.RegisterEnum("scrouter.RouteState", RouteState_name, RouteState_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SCRouter service

type SCRouterClient interface {
	// trigger a "request peers" from a module
	TriggerRequestPeers(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*common.Void, error)
	// get the peers a module knows of (from our database)
	GetPeers(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*PeerList, error)
	// a command reply received. (called by scserver/scmodcoms)
	CommandReply(ctx context.Context, in *singingcat.Command, opts ...grpc.CallOption) (*common.Void, error)
	// request next hop from server (for scserver to know where to send stuff to)
	GetNextHopFromServer(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*NextHopResponse, error)
	// add route
	AddRoute(ctx context.Context, in *RouteRequest, opts ...grpc.CallOption) (*common.Void, error)
	// delete route
	DelRoute(ctx context.Context, in *RouteRequest, opts ...grpc.CallOption) (*common.Void, error)
	// called after scserver used a given route
	RouteUpdate(ctx context.Context, in *RouteResult, opts ...grpc.CallOption) (*common.Void, error)
	// DEPRECATED device powered up (called by scmodcomms if a device sends 'powerup'). still called by scmodcomms 'dolater'
	DevicePoweredUp(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*common.Void, error)
	// device powered up (called by scmodcomms if a device sends 'powerup')
	DevicePoweredUp2(ctx context.Context, in *scmodcomms.Response, opts ...grpc.CallOption) (*common.Void, error)
	// add Next Hop
	AddNextHop(ctx context.Context, in *NextHop, opts ...grpc.CallOption) (*NextHop, error)
	// remove Next Hop
	RemoveNextHop(ctx context.Context, in *NextHop, opts ...grpc.CallOption) (*common.Void, error)
	// get a full route from here to the module (including nexthop)
	GetFullRoute(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*FullRoute, error)
	// get the current list of outstanding changes to modules
	GetPendingChanges(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*PendingChangesList, error)
	// get all current routes to all modules
	GetAllRoutes(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*RouteList, error)
	// scserver says we sent him a next hop that is not or no longer valid. We are expected to calculate an alternative
	InformInvalidNextHop(ctx context.Context, in *NextHopResponse, opts ...grpc.CallOption) (*NextHopResponse, error)
	// calculate routes and return result. Do not apply or modify any routes though
	CalcRoutes(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*RouteList, error)
}

type sCRouterClient struct {
	cc *grpc.ClientConn
}

func NewSCRouterClient(cc *grpc.ClientConn) SCRouterClient {
	return &sCRouterClient{cc}
}

func (c *sCRouterClient) TriggerRequestPeers(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/TriggerRequestPeers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) GetPeers(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*PeerList, error) {
	out := new(PeerList)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/GetPeers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) CommandReply(ctx context.Context, in *singingcat.Command, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/CommandReply", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) GetNextHopFromServer(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*NextHopResponse, error) {
	out := new(NextHopResponse)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/GetNextHopFromServer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) AddRoute(ctx context.Context, in *RouteRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/AddRoute", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) DelRoute(ctx context.Context, in *RouteRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/DelRoute", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) RouteUpdate(ctx context.Context, in *RouteResult, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/RouteUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) DevicePoweredUp(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/DevicePoweredUp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) DevicePoweredUp2(ctx context.Context, in *scmodcomms.Response, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/DevicePoweredUp2", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) AddNextHop(ctx context.Context, in *NextHop, opts ...grpc.CallOption) (*NextHop, error) {
	out := new(NextHop)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/AddNextHop", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) RemoveNextHop(ctx context.Context, in *NextHop, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/RemoveNextHop", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) GetFullRoute(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*FullRoute, error) {
	out := new(FullRoute)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/GetFullRoute", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) GetPendingChanges(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*PendingChangesList, error) {
	out := new(PendingChangesList)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/GetPendingChanges", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) GetAllRoutes(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*RouteList, error) {
	out := new(RouteList)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/GetAllRoutes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) InformInvalidNextHop(ctx context.Context, in *NextHopResponse, opts ...grpc.CallOption) (*NextHopResponse, error) {
	out := new(NextHopResponse)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/InformInvalidNextHop", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCRouterClient) CalcRoutes(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*RouteList, error) {
	out := new(RouteList)
	err := grpc.Invoke(ctx, "/scrouter.SCRouter/CalcRoutes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SCRouter service

type SCRouterServer interface {
	// trigger a "request peers" from a module
	TriggerRequestPeers(context.Context, *singingcat.ModuleRef) (*common.Void, error)
	// get the peers a module knows of (from our database)
	GetPeers(context.Context, *singingcat.ModuleRef) (*PeerList, error)
	// a command reply received. (called by scserver/scmodcoms)
	CommandReply(context.Context, *singingcat.Command) (*common.Void, error)
	// request next hop from server (for scserver to know where to send stuff to)
	GetNextHopFromServer(context.Context, *singingcat.ModuleRef) (*NextHopResponse, error)
	// add route
	AddRoute(context.Context, *RouteRequest) (*common.Void, error)
	// delete route
	DelRoute(context.Context, *RouteRequest) (*common.Void, error)
	// called after scserver used a given route
	RouteUpdate(context.Context, *RouteResult) (*common.Void, error)
	// DEPRECATED device powered up (called by scmodcomms if a device sends 'powerup'). still called by scmodcomms 'dolater'
	DevicePoweredUp(context.Context, *singingcat.ModuleRef) (*common.Void, error)
	// device powered up (called by scmodcomms if a device sends 'powerup')
	DevicePoweredUp2(context.Context, *scmodcomms.Response) (*common.Void, error)
	// add Next Hop
	AddNextHop(context.Context, *NextHop) (*NextHop, error)
	// remove Next Hop
	RemoveNextHop(context.Context, *NextHop) (*common.Void, error)
	// get a full route from here to the module (including nexthop)
	GetFullRoute(context.Context, *singingcat.ModuleRef) (*FullRoute, error)
	// get the current list of outstanding changes to modules
	GetPendingChanges(context.Context, *common.Void) (*PendingChangesList, error)
	// get all current routes to all modules
	GetAllRoutes(context.Context, *common.Void) (*RouteList, error)
	// scserver says we sent him a next hop that is not or no longer valid. We are expected to calculate an alternative
	InformInvalidNextHop(context.Context, *NextHopResponse) (*NextHopResponse, error)
	// calculate routes and return result. Do not apply or modify any routes though
	CalcRoutes(context.Context, *singingcat.ModuleRef) (*RouteList, error)
}

func RegisterSCRouterServer(s *grpc.Server, srv SCRouterServer) {
	s.RegisterService(&_SCRouter_serviceDesc, srv)
}

func _SCRouter_TriggerRequestPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).TriggerRequestPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/TriggerRequestPeers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).TriggerRequestPeers(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_GetPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).GetPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/GetPeers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).GetPeers(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_CommandReply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.Command)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).CommandReply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/CommandReply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).CommandReply(ctx, req.(*singingcat.Command))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_GetNextHopFromServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).GetNextHopFromServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/GetNextHopFromServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).GetNextHopFromServer(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_AddRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).AddRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/AddRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).AddRoute(ctx, req.(*RouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_DelRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).DelRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/DelRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).DelRoute(ctx, req.(*RouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_RouteUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteResult)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).RouteUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/RouteUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).RouteUpdate(ctx, req.(*RouteResult))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_DevicePoweredUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).DevicePoweredUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/DevicePoweredUp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).DevicePoweredUp(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_DevicePoweredUp2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(scmodcomms.Response)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).DevicePoweredUp2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/DevicePoweredUp2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).DevicePoweredUp2(ctx, req.(*scmodcomms.Response))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_AddNextHop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NextHop)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).AddNextHop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/AddNextHop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).AddNextHop(ctx, req.(*NextHop))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_RemoveNextHop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NextHop)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).RemoveNextHop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/RemoveNextHop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).RemoveNextHop(ctx, req.(*NextHop))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_GetFullRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).GetFullRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/GetFullRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).GetFullRoute(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_GetPendingChanges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).GetPendingChanges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/GetPendingChanges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).GetPendingChanges(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_GetAllRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).GetAllRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/GetAllRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).GetAllRoutes(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_InformInvalidNextHop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NextHopResponse)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).InformInvalidNextHop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/InformInvalidNextHop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).InformInvalidNextHop(ctx, req.(*NextHopResponse))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCRouter_CalcRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCRouterServer).CalcRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scrouter.SCRouter/CalcRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCRouterServer).CalcRoutes(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

var _SCRouter_serviceDesc = grpc.ServiceDesc{
	ServiceName: "scrouter.SCRouter",
	HandlerType: (*SCRouterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TriggerRequestPeers",
			Handler:    _SCRouter_TriggerRequestPeers_Handler,
		},
		{
			MethodName: "GetPeers",
			Handler:    _SCRouter_GetPeers_Handler,
		},
		{
			MethodName: "CommandReply",
			Handler:    _SCRouter_CommandReply_Handler,
		},
		{
			MethodName: "GetNextHopFromServer",
			Handler:    _SCRouter_GetNextHopFromServer_Handler,
		},
		{
			MethodName: "AddRoute",
			Handler:    _SCRouter_AddRoute_Handler,
		},
		{
			MethodName: "DelRoute",
			Handler:    _SCRouter_DelRoute_Handler,
		},
		{
			MethodName: "RouteUpdate",
			Handler:    _SCRouter_RouteUpdate_Handler,
		},
		{
			MethodName: "DevicePoweredUp",
			Handler:    _SCRouter_DevicePoweredUp_Handler,
		},
		{
			MethodName: "DevicePoweredUp2",
			Handler:    _SCRouter_DevicePoweredUp2_Handler,
		},
		{
			MethodName: "AddNextHop",
			Handler:    _SCRouter_AddNextHop_Handler,
		},
		{
			MethodName: "RemoveNextHop",
			Handler:    _SCRouter_RemoveNextHop_Handler,
		},
		{
			MethodName: "GetFullRoute",
			Handler:    _SCRouter_GetFullRoute_Handler,
		},
		{
			MethodName: "GetPendingChanges",
			Handler:    _SCRouter_GetPendingChanges_Handler,
		},
		{
			MethodName: "GetAllRoutes",
			Handler:    _SCRouter_GetAllRoutes_Handler,
		},
		{
			MethodName: "InformInvalidNextHop",
			Handler:    _SCRouter_InformInvalidNextHop_Handler,
		},
		{
			MethodName: "CalcRoutes",
			Handler:    _SCRouter_CalcRoutes_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "golang.singingcat.net/apis/scrouter/scrouter.proto",
}

func init() { proto.RegisterFile("golang.singingcat.net/apis/scrouter/scrouter.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1697 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x58, 0x49, 0x6f, 0x1b, 0x47,
	0x16, 0x36, 0x29, 0x6e, 0x7a, 0x24, 0x25, 0xaa, 0x24, 0x6b, 0x28, 0xc2, 0x30, 0x38, 0x0d, 0xcf,
	0x40, 0xa3, 0x99, 0xa1, 0x65, 0xda, 0x23, 0xcf, 0x18, 0x03, 0x78, 0xb8, 0x49, 0x22, 0x46, 0x26,
	0x85, 0x22, 0x25, 0x20, 0xc8, 0x81, 0x69, 0x77, 0x97, 0xa8, 0x46, 0x9a, 0xdd, 0x4c, 0x77, 0x51,
	0x8a, 0x6e, 0x81, 0x7f, 0x40, 0x72, 0x4f, 0x2e, 0x46, 0x8e, 0xb9, 0xe6, 0x98, 0x7b, 0x72, 0xce,
	0x9f, 0xc9, 0x39, 0xa8, 0xa5, 0x57, 0x2e, 0x91, 0x2e, 0x52, 0xd7, 0xf7, 0xea, 0xbd, 0xaa, 0xb7,
	0x7d, 0x55, 0x45, 0xa8, 0x8f, 0x6d, 0x53, 0xb5, 0xc6, 0x35, 0xd7, 0xb0, 0xc6, 0x86, 0x35, 0xd6,
	0x54, 0x5a, 0xb3, 0x08, 0x7d, 0xae, 0x4e, 0x0d, 0xf7, 0xb9, 0xab, 0x39, 0xf6, 0x8c, 0x12, 0xc7,
	0xff, 0xa8, 0x4d, 0x1d, 0x9b, 0xda, 0x28, 0xe7, 0x8d, 0x2b, 0x35, 0xa9, 0xad, 0xd9, 0x96, 0xa3,
	0xea, 0xb7, 0xb6, 0xad, 0x07, 0xda, 0x9a, 0x3d, 0x99, 0xd8, 0x96, 0xfc, 0x27, 0x34, 0x2b, 0x47,
	0xab, 0x56, 0xf3, 0xb1, 0xd0, 0xa7, 0xd4, 0xfb, 0xc7, 0xca, 0x5d, 0xde, 0x92, 0xf7, 0xe2, 0xef,
	0x7d, 0x56, 0xd1, 0x26, 0xb6, 0xce, 0xf6, 0x14, 0xfe, 0x14, 0x7a, 0xca, 0x21, 0xe4, 0xce, 0x09,
	0x71, 0xce, 0x0c, 0x97, 0xa2, 0x67, 0x90, 0x66, 0xdf, 0x6e, 0x39, 0x51, 0x5d, 0xdb, 0xcf, 0xd7,
	0x37, 0x6a, 0x7e, 0x0c, 0x18, 0x8c, 0x85, 0x50, 0xf9, 0x29, 0x01, 0x29, 0xf6, 0x85, 0xfe, 0x09,
	0x99, 0x77, 0xb6, 0x3e, 0x33, 0x49, 0x39, 0x51, 0x4d, 0xec, 0xe7, 0xeb, 0x8f, 0xc3, 0x8b, 0x0b,
	0x09, 0x26, 0x57, 0x58, 0x4e, 0x42, 0x07, 0x90, 0x69, 0x93, 0x1b, 0x43, 0x23, 0xe5, 0x64, 0x35,
	0xb1, 0xbf, 0x51, 0x47, 0xe1, 0xe9, 0x42, 0x82, 0xe5, 0x0c, 0x54, 0x03, 0x74, 0xaa, 0xba, 0x2d,
	0xd3, 0x9e, 0xe9, 0x2d, 0xdb, 0xb2, 0x88, 0x46, 0x0d, 0xdb, 0x2a, 0xaf, 0x55, 0x13, 0xfb, 0x39,
	0xbc, 0x40, 0x82, 0xf6, 0x61, 0x73, 0x60, 0x8c, 0x2d, 0xd5, 0xec, 0x5a, 0xba, 0xa1, 0xa9, 0xd4,
	0x76, 0xca, 0xa9, 0x6a, 0x62, 0xbf, 0x88, 0xe3, 0xb0, 0xf2, 0x19, 0x14, 0xcf, 0x55, 0x7a, 0xdd,
	0xb0, 0x74, 0xcc, 0x5c, 0x73, 0x91, 0x02, 0x29, 0x06, 0x48, 0x1f, 0xc2, 0x3e, 0xab, 0xf4, 0x1a,
	0x73, 0x19, 0xfa, 0x3b, 0x64, 0xc4, 0xec, 0x72, 0x92, 0x47, 0x66, 0x3b, 0x36, 0x8b, 0x7d, 0x62,
	0x39, 0x45, 0xf9, 0x2d, 0x21, 0x2c, 0xa2, 0x0d, 0x48, 0x76, 0xdb, 0xdc, 0x6e, 0x0a, 0x27, 0xbb,
	0x6d, 0x54, 0x86, 0xac, 0x08, 0x45, 0x83, 0x47, 0x20, 0x85, 0xbd, 0x61, 0x20, 0x69, 0x72, 0x1f,
	0x7d, 0x49, 0x13, 0x3d, 0x05, 0x68, 0x1b, 0x57, 0x57, 0x86, 0x36, 0x33, 0xe9, 0x9d, 0xf4, 0x29,
	0x84, 0xa0, 0x0a, 0xe4, 0xda, 0x86, 0xab, 0xbe, 0x37, 0x89, 0x5e, 0x4e, 0xf3, 0xf0, 0xf8, 0x63,
	0xa6, 0x3b, 0x1c, 0xf8, 0xd2, 0x8c, 0xd0, 0x0d, 0x10, 0xa4, 0x40, 0x96, 0xed, 0xf3, 0xff, 0xe4,
	0xae, 0x9c, 0xad, 0x26, 0xf6, 0x0b, 0xcd, 0xdc, 0x0f, 0x1f, 0xf6, 0x52, 0xd4, 0x99, 0x11, 0xec,
	0x09, 0xd0, 0x01, 0x94, 0x86, 0x83, 0x33, 0xd5, 0xa5, 0x2d, 0xd5, 0xd4, 0x66, 0xa6, 0x4a, 0x89,
	0x5e, 0xce, 0x71, 0x4b, 0x73, 0xb8, 0xf2, 0x31, 0x05, 0xeb, 0x7e, 0x38, 0xe6, 0xbc, 0xff, 0x8f,
	0x8c, 0x73, 0x72, 0x51, 0x9c, 0x9b, 0x8f, 0xbf, 0xfd, 0xb0, 0x97, 0x99, 0x19, 0x16, 0x3d, 0x7a,
	0xf5, 0xfd, 0x87, 0xbd, 0xec, 0x54, 0xa5, 0xd7, 0x35, 0x43, 0x97, 0xe1, 0xaf, 0x40, 0xae, 0x6f,
	0xc9, 0x52, 0x13, 0xf1, 0xf1, 0xc7, 0x2c, 0x74, 0x3d, 0xf2, 0x25, 0x3d, 0xb5, 0xa7, 0x3c, 0x3a,
	0x29, 0xec, 0x0d, 0xd1, 0x7f, 0x61, 0xfd, 0xd2, 0x50, 0x65, 0xc9, 0xa5, 0x97, 0x95, 0x5c, 0x13,
	0x82, 0x95, 0x71, 0xa0, 0x80, 0xfe, 0x07, 0xc0, 0xfd, 0x18, 0x50, 0x95, 0x12, 0x1e, 0xbc, 0x8d,
	0xfa, 0x4e, 0xb0, 0xe9, 0x40, 0x16, 0x31, 0x10, 0xd2, 0x41, 0x7f, 0x85, 0x8d, 0x63, 0xdb, 0xb9,
	0x55, 0x1d, 0xfd, 0x58, 0x35, 0xcc, 0x99, 0x43, 0x78, 0x94, 0x8b, 0x38, 0x86, 0xb2, 0x5a, 0x17,
	0xa1, 0x6c, 0x4c, 0xa7, 0xe6, 0x5d, 0x83, 0x52, 0x32, 0x99, 0x52, 0x19, 0xe4, 0x05, 0x12, 0xf4,
	0x0c, 0x8a, 0x01, 0x6a, 0x10, 0xbd, 0xbc, 0xce, 0xa7, 0x46, 0x41, 0x74, 0x08, 0xdb, 0x02, 0xc0,
	0x64, 0x62, 0xdf, 0x10, 0xcf, 0x2c, 0xf0, 0xb9, 0x8b, 0x44, 0x81, 0x5d, 0x01, 0xeb, 0xe5, 0x7c,
	0xd8, 0xae, 0x04, 0x59, 0x51, 0xf1, 0xdd, 0xf4, 0x1d, 0x9d, 0x38, 0xe5, 0x82, 0x28, 0xaa, 0x00,
	0x41, 0x4f, 0x60, 0xbd, 0xeb, 0x62, 0x72, 0x43, 0x1c, 0x97, 0x94, 0x8b, 0xbc, 0x22, 0x03, 0x40,
	0xf9, 0x3a, 0x09, 0x99, 0x76, 0x93, 0xb3, 0x47, 0xbc, 0x3e, 0x2a, 0x90, 0x13, 0x29, 0xed, 0xb6,
	0x65, 0x7b, 0xf8, 0x63, 0xa4, 0x40, 0x81, 0xe9, 0xf8, 0x72, 0x51, 0x04, 0x11, 0x0c, 0x1d, 0xf9,
	0xf4, 0x92, 0xba, 0x57, 0xae, 0x57, 0x53, 0x4d, 0x7a, 0x29, 0xd5, 0x28, 0x50, 0x10, 0xf1, 0x98,
	0xda, 0x0e, 0xf5, 0xfb, 0x2a, 0x82, 0x2d, 0xa2, 0xa3, 0xec, 0x62, 0x3a, 0xfa, 0x35, 0x01, 0x79,
	0xe1, 0x82, 0x28, 0x9a, 0x78, 0x54, 0x9e, 0xc5, 0xa3, 0x12, 0x6a, 0xd2, 0x20, 0x3e, 0x35, 0x40,
	0x6c, 0x7d, 0xce, 0xcf, 0x98, 0x7c, 0x31, 0x23, 0x2e, 0xdb, 0xd9, 0x9a, 0x28, 0xa1, 0x79, 0x09,
	0xaa, 0xc3, 0x8e, 0x8f, 0x36, 0xb4, 0xcf, 0x31, 0xd1, 0x88, 0xc1, 0x32, 0x2e, 0xf8, 0x65, 0xa1,
	0x8c, 0xf9, 0xc4, 0xfb, 0xdd, 0x9e, 0x0c, 0x98, 0x1d, 0x4b, 0x36, 0x55, 0x11, 0xc7, 0x61, 0xe5,
	0x9b, 0x84, 0xdf, 0x93, 0x73, 0xfe, 0x1c, 0xc2, 0xc6, 0x50, 0x75, 0xc6, 0x84, 0x2e, 0xf5, 0x2a,
	0x26, 0x67, 0xeb, 0x4a, 0x63, 0xb1, 0xf4, 0xc7, 0x61, 0x46, 0x05, 0x2d, 0x87, 0x70, 0x8a, 0x12,
	0x8e, 0x78, 0x43, 0xe5, 0x53, 0xdf, 0x06, 0x26, 0xee, 0xd4, 0xb6, 0x5c, 0x12, 0x29, 0xb7, 0x44,
	0xac, 0xdc, 0x76, 0x21, 0xd3, 0xb3, 0x75, 0x6f, 0x73, 0x45, 0x2c, 0x47, 0x68, 0x07, 0xd2, 0x97,
	0xaa, 0x69, 0xe8, 0xf2, 0x20, 0x12, 0x03, 0xe5, 0xbb, 0x35, 0xc8, 0xb6, 0x9b, 0x8b, 0x49, 0x6f,
	0x55, 0x51, 0x57, 0x21, 0x2f, 0x5d, 0x55, 0xa9, 0x76, 0x2d, 0x9d, 0x0a, 0x43, 0x6c, 0xc6, 0x80,
	0x58, 0x3a, 0x71, 0xc4, 0x0c, 0xc1, 0x6f, 0x61, 0x28, 0xcc, 0x7e, 0xe9, 0x28, 0xfb, 0x55, 0x21,
	0x2f, 0x0a, 0x5c, 0xe8, 0x8a, 0x2a, 0x0d, 0x43, 0x82, 0x55, 0x65, 0xcb, 0x88, 0xea, 0xf4, 0xc7,
	0x4c, 0x3b, 0xcc, 0x30, 0x82, 0x8c, 0xc2, 0x10, 0x3b, 0x18, 0xe6, 0x38, 0x4b, 0x10, 0xd1, 0x1c,
	0xce, 0x3d, 0xb5, 0x9b, 0xa4, 0x4d, 0x4c, 0xc2, 0x92, 0x03, 0x3c, 0x7a, 0x61, 0x88, 0x15, 0xa4,
	0xdc, 0x78, 0x77, 0x32, 0x35, 0x0d, 0xcd, 0xa0, 0x3c, 0x9e, 0x9c, 0x82, 0x52, 0x78, 0xa1, 0x8c,
	0xf1, 0x55, 0x78, 0x15, 0x97, 0x93, 0x51, 0x0a, 0x47, 0x41, 0xe5, 0xe7, 0x24, 0x14, 0xc4, 0xf9,
	0x2c, 0xaa, 0xff, 0xa1, 0xb7, 0x96, 0xd7, 0xd1, 0x2c, 0x25, 0x57, 0xe9, 0x44, 0x92, 0xf7, 0x3a,
	0x9a, 0xbc, 0xb5, 0x95, 0x8a, 0xe1, 0x9c, 0x3e, 0x8f, 0x9e, 0x68, 0x4b, 0x95, 0xfc, 0x54, 0xbf,
	0x8a, 0xa6, 0x7a, 0xe9, 0x51, 0x17, 0x4d, 0x7f, 0x2d, 0x94, 0xfe, 0xcc, 0x52, 0x15, 0x7f, 0x8e,
	0xf2, 0x55, 0x02, 0xf2, 0x32, 0x90, 0xee, 0xcc, 0xa4, 0xe8, 0x65, 0xb0, 0x4d, 0x11, 0xc8, 0xbd,
	0xe0, 0x74, 0x8c, 0x35, 0x5b, 0xb0, 0xd5, 0x32, 0x64, 0x07, 0x33, 0x4d, 0x23, 0xae, 0xcb, 0x23,
	0x99, 0xc3, 0xde, 0x90, 0xd1, 0xea, 0x3b, 0xc3, 0x34, 0x0d, 0x97, 0x68, 0xb6, 0xa5, 0xbb, 0x1e,
	0xc5, 0x87, 0x31, 0xa5, 0x0f, 0x69, 0x91, 0x7a, 0x05, 0x0a, 0xa7, 0xb6, 0x4b, 0x63, 0x0d, 0x1c,
	0xc1, 0xd8, 0x1c, 0xb6, 0x6a, 0xac, 0xfd, 0x22, 0x98, 0xf2, 0x63, 0x12, 0x10, 0xb7, 0x78, 0x31,
	0xd5, 0x55, 0x4a, 0xbc, 0x13, 0xf9, 0x2f, 0x90, 0x11, 0x09, 0x91, 0x9e, 0x15, 0x6b, 0xe2, 0xa6,
	0x2d, 0x63, 0x2f, 0x85, 0x8c, 0x99, 0xe4, 0x51, 0x6e, 0x58, 0xe3, 0x8e, 0xe3, 0xd8, 0x8e, 0xe4,
	0x8b, 0x38, 0xcc, 0x4a, 0x15, 0x13, 0xcd, 0x98, 0x1a, 0xc4, 0xa2, 0x8c, 0x4b, 0x24, 0x35, 0x47,
	0x41, 0xf4, 0x1a, 0x36, 0x7d, 0x40, 0x96, 0x68, 0x6a, 0xd1, 0xfa, 0xf1, 0x59, 0xfc, 0xa2, 0xc7,
	0x2b, 0x8f, 0xdb, 0x4e, 0xcb, 0x8b, 0x9e, 0x8f, 0xa0, 0x17, 0x50, 0x08, 0x93, 0x2a, 0x4f, 0xf7,
	0x9c, 0xd5, 0xc8, 0x14, 0x46, 0x0e, 0x3e, 0xcd, 0x4b, 0x72, 0xf0, 0xf9, 0xfd, 0x97, 0x04, 0x6c,
	0x86, 0xa2, 0xc6, 0x4f, 0xf3, 0x7b, 0x86, 0xec, 0x21, 0x6f, 0x80, 0x3f, 0x8b, 0x67, 0x86, 0xec,
	0x9c, 0x98, 0x41, 0xf1, 0x02, 0xd9, 0x81, 0x74, 0x43, 0xd7, 0x25, 0xdf, 0xe7, 0xb0, 0x18, 0x2c,
	0x3a, 0x7d, 0xd3, 0x8b, 0x4f, 0xdf, 0x23, 0x58, 0x3f, 0x9e, 0x99, 0xa6, 0x28, 0xaa, 0xbf, 0xf9,
	0x97, 0x7c, 0xf1, 0xfc, 0xd9, 0x0a, 0xea, 0x59, 0xd2, 0xbb, 0x7f, 0xc5, 0x7f, 0x0b, 0xe8, 0x9c,
	0x58, 0x2c, 0xbf, 0xad, 0x6b, 0xd5, 0x1a, 0x13, 0x97, 0x3f, 0x9f, 0x1e, 0x60, 0xe0, 0x08, 0xd6,
	0xf9, 0xd7, 0x03, 0xf5, 0x0e, 0x06, 0xb2, 0x07, 0x79, 0x59, 0xb9, 0x68, 0x13, 0xf2, 0xb8, 0x7f,
	0x31, 0xec, 0x8c, 0x2e, 0x7a, 0xed, 0xce, 0x71, 0xe9, 0x11, 0xaa, 0xc0, 0x6e, 0xaf, 0x3f, 0x3a,
	0xed, 0x0f, 0x86, 0x02, 0x3f, 0xee, 0xe3, 0x11, 0xff, 0x2a, 0x11, 0xf4, 0x27, 0xd8, 0xee, 0xf5,
	0xc5, 0x68, 0xd4, 0xea, 0xf7, 0x8e, 0xbb, 0x27, 0x17, 0xb8, 0xd3, 0x2e, 0x5d, 0x1d, 0xe8, 0xe1,
	0xab, 0x2e, 0xca, 0x43, 0x16, 0x77, 0xde, 0xf5, 0x2f, 0x3b, 0xed, 0xd2, 0x23, 0x36, 0x68, 0x9c,
	0x9f, 0x9f, 0x75, 0x3b, 0xed, 0x52, 0x02, 0x6d, 0x41, 0x71, 0xd8, 0x1f, 0x35, 0x3b, 0x23, 0x0f,
	0x4a, 0x06, 0x90, 0xa7, 0xb2, 0x86, 0x76, 0x01, 0xf5, 0xfa, 0xc3, 0x51, 0xeb, 0x02, 0xe3, 0x4e,
	0x6f, 0x78, 0xf6, 0xc9, 0xe8, 0x62, 0xd0, 0x69, 0x97, 0x52, 0xf5, 0x8f, 0x59, 0xc8, 0x0d, 0x5a,
	0x7c, 0x21, 0x07, 0xbd, 0x81, 0xed, 0xa1, 0x63, 0x8c, 0xc7, 0xc4, 0x91, 0xb4, 0xcc, 0xaf, 0x1b,
	0x68, 0x31, 0xd3, 0x55, 0x0a, 0x35, 0xf9, 0xa0, 0xbe, 0xb4, 0x0d, 0x1d, 0xfd, 0x0b, 0x72, 0x27,
	0x64, 0xb5, 0x02, 0x8a, 0xbe, 0x5c, 0x79, 0x94, 0x5f, 0x40, 0xa1, 0x65, 0x4f, 0x26, 0xaa, 0xa5,
	0x63, 0x32, 0x35, 0xef, 0xd0, 0x76, 0x58, 0x55, 0x4a, 0x62, 0x2b, 0x9d, 0xc2, 0xce, 0x09, 0xa1,
	0x92, 0xbb, 0x8e, 0x1d, 0x76, 0xc5, 0x71, 0x6e, 0x88, 0xb3, 0x6c, 0xd5, 0xe5, 0x04, 0x88, 0x0e,
	0x21, 0xd7, 0xd0, 0xc5, 0x8b, 0x13, 0xed, 0xc6, 0x5e, 0x11, 0x32, 0x02, 0xb1, 0xb5, 0x0f, 0x21,
	0xd7, 0x26, 0xe6, 0x43, 0x34, 0xea, 0xb2, 0x36, 0x44, 0x57, 0xb2, 0x4d, 0xc6, 0x94, 0x18, 0x6d,
	0xc7, 0x74, 0x8e, 0x60, 0x53, 0x74, 0xdb, 0xb9, 0x7d, 0x4b, 0x1c, 0xa2, 0x5f, 0x4c, 0xef, 0x97,
	0x83, 0x23, 0x28, 0xc5, 0xf4, 0xea, 0x88, 0xbd, 0x8e, 0xfc, 0x1f, 0x17, 0x3c, 0xcf, 0xe7, 0xf6,
	0x08, 0x0d, 0x5d, 0xf7, 0x4e, 0x83, 0xad, 0xb9, 0x80, 0x55, 0xe6, 0x21, 0x74, 0xc8, 0xc8, 0x93,
	0x3d, 0x3e, 0x56, 0xa8, 0x45, 0x57, 0x79, 0x03, 0x85, 0x13, 0x42, 0x83, 0xce, 0x5e, 0xe2, 0x52,
	0xe8, 0x15, 0x1f, 0xcc, 0x7d, 0x0b, 0x5b, 0xbc, 0xba, 0xc2, 0xdd, 0x8d, 0x22, 0xe6, 0x2b, 0x4f,
	0xc2, 0xd5, 0x35, 0xc7, 0x02, 0x2f, 0xf8, 0xe2, 0x0d, 0x69, 0x2f, 0xae, 0xbb, 0x1d, 0xcb, 0x0a,
	0x57, 0x39, 0x83, 0x9d, 0xae, 0x75, 0x65, 0x3b, 0x93, 0xae, 0x75, 0xc3, 0xae, 0x94, 0x9e, 0xa3,
	0xcb, 0x0b, 0x6a, 0x55, 0xad, 0xfd, 0x1b, 0x80, 0x3d, 0xca, 0xe5, 0xf2, 0x7f, 0xec, 0xbb, 0xbf,
	0x8f, 0xe6, 0x53, 0x78, 0x62, 0x11, 0x1a, 0x56, 0x50, 0xa7, 0x86, 0xeb, 0xcf, 0x7c, 0x9f, 0xe1,
	0x3f, 0x19, 0xbd, 0xfc, 0x3d, 0x00, 0x00, 0xff, 0xff, 0x4d, 0x2b, 0x13, 0x0e, 0x40, 0x13, 0x00,
	0x00,
}
