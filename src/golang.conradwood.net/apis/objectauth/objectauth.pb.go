// Code generated by protoc-gen-go.
// source: protos/golang.conradwood.net/apis/objectauth/objectauth.proto
// DO NOT EDIT!

/*
Package objectauth is a generated protocol buffer package.

It is generated from these files:
	protos/golang.conradwood.net/apis/objectauth/objectauth.proto

It has these top-level messages:
	GroupToComposite
	UserToObject
	GroupToObject
	AuthRequest
	AuthResponse
	ObjectType
	ObjectIDList
	GrantUserRequest
	GrantGroupRequest
	PermissionSet
	AccessRightList
	ResolveResponse
	IDGrantRequest
	ResolveRequest
	AllAccessRequest
	AllAccessResponse
	GrantAllAccessRequest
	ServiceAccess
*/
package objectauth

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"
import auth "golang.conradwood.net/apis/auth"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type OBJECTTYPE int32

const (
	OBJECTTYPE_UNDEFINED        OBJECTTYPE = 0
	OBJECTTYPE_Service          OBJECTTYPE = 1
	OBJECTTYPE_Artefact         OBJECTTYPE = 2
	OBJECTTYPE_GitRepository    OBJECTTYPE = 3
	OBJECTTYPE_SingingCatModule OBJECTTYPE = 4
	OBJECTTYPE_Proto            OBJECTTYPE = 5
	OBJECTTYPE_Domain           OBJECTTYPE = 6
	OBJECTTYPE_UserAppFlags     OBJECTTYPE = 7
)

var OBJECTTYPE_name = map[int32]string{
	0: "UNDEFINED",
	1: "Service",
	2: "Artefact",
	3: "GitRepository",
	4: "SingingCatModule",
	5: "Proto",
	6: "Domain",
	7: "UserAppFlags",
}
var OBJECTTYPE_value = map[string]int32{
	"UNDEFINED":        0,
	"Service":          1,
	"Artefact":         2,
	"GitRepository":    3,
	"SingingCatModule": 4,
	"Proto":            5,
	"Domain":           6,
	"UserAppFlags":     7,
}

func (x OBJECTTYPE) String() string {
	return proto.EnumName(OBJECTTYPE_name, int32(x))
}
func (OBJECTTYPE) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type COMPOSITETYPE int32

const (
	COMPOSITETYPE_COMP_UNDEFINED COMPOSITETYPE = 0
	COMPOSITETYPE_Software       COMPOSITETYPE = 1
)

var COMPOSITETYPE_name = map[int32]string{
	0: "COMP_UNDEFINED",
	1: "Software",
}
var COMPOSITETYPE_value = map[string]int32{
	"COMP_UNDEFINED": 0,
	"Software":       1,
}

func (x COMPOSITETYPE) String() string {
	return proto.EnumName(COMPOSITETYPE_name, int32(x))
}
func (COMPOSITETYPE) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// composite types are some that include multiple, related objecttpyes, for example, a git repository and its artefacts and protos. in this case the ID is specific to _something_ in the composite relationships, in the example above, it is the "git repository id", from which the others are derived
type GroupToComposite struct {
	ID         uint64        `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	ObjectType COMPOSITETYPE `protobuf:"varint,2,opt,name=ObjectType,enum=objectauth.COMPOSITETYPE" json:"ObjectType,omitempty"`
	ObjectID   uint64        `protobuf:"varint,3,opt,name=ObjectID" json:"ObjectID,omitempty"`
	GroupID    string        `protobuf:"bytes,4,opt,name=GroupID" json:"GroupID,omitempty"`
	Active     bool          `protobuf:"varint,5,opt,name=Active" json:"Active,omitempty"`
	Read       bool          `protobuf:"varint,6,opt,name=Read" json:"Read,omitempty"`
	Write      bool          `protobuf:"varint,7,opt,name=Write" json:"Write,omitempty"`
	Execute    bool          `protobuf:"varint,8,opt,name=Execute" json:"Execute,omitempty"`
	View       bool          `protobuf:"varint,9,opt,name=View" json:"View,omitempty"`
}

func (m *GroupToComposite) Reset()                    { *m = GroupToComposite{} }
func (m *GroupToComposite) String() string            { return proto.CompactTextString(m) }
func (*GroupToComposite) ProtoMessage()               {}
func (*GroupToComposite) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *GroupToComposite) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *GroupToComposite) GetObjectType() COMPOSITETYPE {
	if m != nil {
		return m.ObjectType
	}
	return COMPOSITETYPE_COMP_UNDEFINED
}

func (m *GroupToComposite) GetObjectID() uint64 {
	if m != nil {
		return m.ObjectID
	}
	return 0
}

func (m *GroupToComposite) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

func (m *GroupToComposite) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *GroupToComposite) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *GroupToComposite) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

func (m *GroupToComposite) GetExecute() bool {
	if m != nil {
		return m.Execute
	}
	return false
}

func (m *GroupToComposite) GetView() bool {
	if m != nil {
		return m.View
	}
	return false
}

// database user to object acl
type UserToObject struct {
	ID         uint64     `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	ObjectType OBJECTTYPE `protobuf:"varint,2,opt,name=ObjectType,enum=objectauth.OBJECTTYPE" json:"ObjectType,omitempty"`
	ObjectID   uint64     `protobuf:"varint,3,opt,name=ObjectID" json:"ObjectID,omitempty"`
	UserID     string     `protobuf:"bytes,4,opt,name=UserID" json:"UserID,omitempty"`
	Active     bool       `protobuf:"varint,5,opt,name=Active" json:"Active,omitempty"`
	Read       bool       `protobuf:"varint,6,opt,name=Read" json:"Read,omitempty"`
	Write      bool       `protobuf:"varint,7,opt,name=Write" json:"Write,omitempty"`
	Execute    bool       `protobuf:"varint,8,opt,name=Execute" json:"Execute,omitempty"`
	View       bool       `protobuf:"varint,9,opt,name=View" json:"View,omitempty"`
}

func (m *UserToObject) Reset()                    { *m = UserToObject{} }
func (m *UserToObject) String() string            { return proto.CompactTextString(m) }
func (*UserToObject) ProtoMessage()               {}
func (*UserToObject) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *UserToObject) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserToObject) GetObjectType() OBJECTTYPE {
	if m != nil {
		return m.ObjectType
	}
	return OBJECTTYPE_UNDEFINED
}

func (m *UserToObject) GetObjectID() uint64 {
	if m != nil {
		return m.ObjectID
	}
	return 0
}

func (m *UserToObject) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *UserToObject) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *UserToObject) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *UserToObject) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

func (m *UserToObject) GetExecute() bool {
	if m != nil {
		return m.Execute
	}
	return false
}

func (m *UserToObject) GetView() bool {
	if m != nil {
		return m.View
	}
	return false
}

// database group to object acl
type GroupToObject struct {
	ID         uint64     `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	ObjectType OBJECTTYPE `protobuf:"varint,2,opt,name=ObjectType,enum=objectauth.OBJECTTYPE" json:"ObjectType,omitempty"`
	ObjectID   uint64     `protobuf:"varint,3,opt,name=ObjectID" json:"ObjectID,omitempty"`
	GroupID    string     `protobuf:"bytes,4,opt,name=GroupID" json:"GroupID,omitempty"`
	Active     bool       `protobuf:"varint,5,opt,name=Active" json:"Active,omitempty"`
	Read       bool       `protobuf:"varint,6,opt,name=Read" json:"Read,omitempty"`
	Write      bool       `protobuf:"varint,7,opt,name=Write" json:"Write,omitempty"`
	Execute    bool       `protobuf:"varint,8,opt,name=Execute" json:"Execute,omitempty"`
	View       bool       `protobuf:"varint,9,opt,name=View" json:"View,omitempty"`
}

func (m *GroupToObject) Reset()                    { *m = GroupToObject{} }
func (m *GroupToObject) String() string            { return proto.CompactTextString(m) }
func (*GroupToObject) ProtoMessage()               {}
func (*GroupToObject) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *GroupToObject) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *GroupToObject) GetObjectType() OBJECTTYPE {
	if m != nil {
		return m.ObjectType
	}
	return OBJECTTYPE_UNDEFINED
}

func (m *GroupToObject) GetObjectID() uint64 {
	if m != nil {
		return m.ObjectID
	}
	return 0
}

func (m *GroupToObject) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

func (m *GroupToObject) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *GroupToObject) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *GroupToObject) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

func (m *GroupToObject) GetExecute() bool {
	if m != nil {
		return m.Execute
	}
	return false
}

func (m *GroupToObject) GetView() bool {
	if m != nil {
		return m.View
	}
	return false
}

//
// authenticate against objecttype and id. Using context to identify user
type AuthRequest struct {
	ObjectType OBJECTTYPE `protobuf:"varint,1,opt,name=ObjectType,enum=objectauth.OBJECTTYPE" json:"ObjectType,omitempty"`
	ObjectID   uint64     `protobuf:"varint,2,opt,name=ObjectID" json:"ObjectID,omitempty"`
}

func (m *AuthRequest) Reset()                    { *m = AuthRequest{} }
func (m *AuthRequest) String() string            { return proto.CompactTextString(m) }
func (*AuthRequest) ProtoMessage()               {}
func (*AuthRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *AuthRequest) GetObjectType() OBJECTTYPE {
	if m != nil {
		return m.ObjectType
	}
	return OBJECTTYPE_UNDEFINED
}

func (m *AuthRequest) GetObjectID() uint64 {
	if m != nil {
		return m.ObjectID
	}
	return 0
}

type AuthResponse struct {
	Granted     bool           `protobuf:"varint,1,opt,name=Granted" json:"Granted,omitempty"`
	Permissions *PermissionSet `protobuf:"bytes,2,opt,name=Permissions" json:"Permissions,omitempty"`
}

func (m *AuthResponse) Reset()                    { *m = AuthResponse{} }
func (m *AuthResponse) String() string            { return proto.CompactTextString(m) }
func (*AuthResponse) ProtoMessage()               {}
func (*AuthResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *AuthResponse) GetGranted() bool {
	if m != nil {
		return m.Granted
	}
	return false
}

func (m *AuthResponse) GetPermissions() *PermissionSet {
	if m != nil {
		return m.Permissions
	}
	return nil
}

type ObjectType struct {
	ObjectType OBJECTTYPE `protobuf:"varint,1,opt,name=ObjectType,enum=objectauth.OBJECTTYPE" json:"ObjectType,omitempty"`
}

func (m *ObjectType) Reset()                    { *m = ObjectType{} }
func (m *ObjectType) String() string            { return proto.CompactTextString(m) }
func (*ObjectType) ProtoMessage()               {}
func (*ObjectType) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ObjectType) GetObjectType() OBJECTTYPE {
	if m != nil {
		return m.ObjectType
	}
	return OBJECTTYPE_UNDEFINED
}

type ObjectIDList struct {
	ObjectIDs []uint64 `protobuf:"varint,1,rep,packed,name=ObjectIDs" json:"ObjectIDs,omitempty"`
}

func (m *ObjectIDList) Reset()                    { *m = ObjectIDList{} }
func (m *ObjectIDList) String() string            { return proto.CompactTextString(m) }
func (*ObjectIDList) ProtoMessage()               {}
func (*ObjectIDList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ObjectIDList) GetObjectIDs() []uint64 {
	if m != nil {
		return m.ObjectIDs
	}
	return nil
}

type GrantUserRequest struct {
	ObjectType OBJECTTYPE `protobuf:"varint,1,opt,name=ObjectType,enum=objectauth.OBJECTTYPE" json:"ObjectType,omitempty"`
	ObjectID   uint64     `protobuf:"varint,2,opt,name=ObjectID" json:"ObjectID,omitempty"`
	UserID     string     `protobuf:"bytes,3,opt,name=UserID" json:"UserID,omitempty"`
	Read       bool       `protobuf:"varint,4,opt,name=Read" json:"Read,omitempty"`
	Write      bool       `protobuf:"varint,5,opt,name=Write" json:"Write,omitempty"`
	Execute    bool       `protobuf:"varint,6,opt,name=Execute" json:"Execute,omitempty"`
	View       bool       `protobuf:"varint,7,opt,name=View" json:"View,omitempty"`
}

func (m *GrantUserRequest) Reset()                    { *m = GrantUserRequest{} }
func (m *GrantUserRequest) String() string            { return proto.CompactTextString(m) }
func (*GrantUserRequest) ProtoMessage()               {}
func (*GrantUserRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *GrantUserRequest) GetObjectType() OBJECTTYPE {
	if m != nil {
		return m.ObjectType
	}
	return OBJECTTYPE_UNDEFINED
}

func (m *GrantUserRequest) GetObjectID() uint64 {
	if m != nil {
		return m.ObjectID
	}
	return 0
}

func (m *GrantUserRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *GrantUserRequest) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *GrantUserRequest) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

func (m *GrantUserRequest) GetExecute() bool {
	if m != nil {
		return m.Execute
	}
	return false
}

func (m *GrantUserRequest) GetView() bool {
	if m != nil {
		return m.View
	}
	return false
}

type GrantGroupRequest struct {
	ObjectType OBJECTTYPE `protobuf:"varint,1,opt,name=ObjectType,enum=objectauth.OBJECTTYPE" json:"ObjectType,omitempty"`
	ObjectID   uint64     `protobuf:"varint,2,opt,name=ObjectID" json:"ObjectID,omitempty"`
	GroupID    string     `protobuf:"bytes,3,opt,name=GroupID" json:"GroupID,omitempty"`
	Read       bool       `protobuf:"varint,4,opt,name=Read" json:"Read,omitempty"`
	Write      bool       `protobuf:"varint,5,opt,name=Write" json:"Write,omitempty"`
	Execute    bool       `protobuf:"varint,6,opt,name=Execute" json:"Execute,omitempty"`
	View       bool       `protobuf:"varint,7,opt,name=View" json:"View,omitempty"`
}

func (m *GrantGroupRequest) Reset()                    { *m = GrantGroupRequest{} }
func (m *GrantGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*GrantGroupRequest) ProtoMessage()               {}
func (*GrantGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *GrantGroupRequest) GetObjectType() OBJECTTYPE {
	if m != nil {
		return m.ObjectType
	}
	return OBJECTTYPE_UNDEFINED
}

func (m *GrantGroupRequest) GetObjectID() uint64 {
	if m != nil {
		return m.ObjectID
	}
	return 0
}

func (m *GrantGroupRequest) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

func (m *GrantGroupRequest) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *GrantGroupRequest) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

func (m *GrantGroupRequest) GetExecute() bool {
	if m != nil {
		return m.Execute
	}
	return false
}

func (m *GrantGroupRequest) GetView() bool {
	if m != nil {
		return m.View
	}
	return false
}

type PermissionSet struct {
	Read    bool `protobuf:"varint,1,opt,name=Read" json:"Read,omitempty"`
	Write   bool `protobuf:"varint,2,opt,name=Write" json:"Write,omitempty"`
	Execute bool `protobuf:"varint,3,opt,name=Execute" json:"Execute,omitempty"`
	View    bool `protobuf:"varint,4,opt,name=View" json:"View,omitempty"`
}

func (m *PermissionSet) Reset()                    { *m = PermissionSet{} }
func (m *PermissionSet) String() string            { return proto.CompactTextString(m) }
func (*PermissionSet) ProtoMessage()               {}
func (*PermissionSet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *PermissionSet) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *PermissionSet) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

func (m *PermissionSet) GetExecute() bool {
	if m != nil {
		return m.Execute
	}
	return false
}

func (m *PermissionSet) GetView() bool {
	if m != nil {
		return m.View
	}
	return false
}

type AccessRightList struct {
	ObjectType OBJECTTYPE `protobuf:"varint,1,opt,name=ObjectType,enum=objectauth.OBJECTTYPE" json:"ObjectType,omitempty"`
	ObjectID   uint64     `protobuf:"varint,2,opt,name=ObjectID" json:"ObjectID,omitempty"`
	// GroupID to PermissionSet
	GroupPermissions map[string]*PermissionSet `protobuf:"bytes,3,rep,name=GroupPermissions" json:"GroupPermissions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// UserID to Permission Set
	UserPermissions      map[string]*PermissionSet `protobuf:"bytes,4,rep,name=UserPermissions" json:"UserPermissions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	EffectivePermissions *PermissionSet            `protobuf:"bytes,5,opt,name=EffectivePermissions" json:"EffectivePermissions,omitempty"`
}

func (m *AccessRightList) Reset()                    { *m = AccessRightList{} }
func (m *AccessRightList) String() string            { return proto.CompactTextString(m) }
func (*AccessRightList) ProtoMessage()               {}
func (*AccessRightList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *AccessRightList) GetObjectType() OBJECTTYPE {
	if m != nil {
		return m.ObjectType
	}
	return OBJECTTYPE_UNDEFINED
}

func (m *AccessRightList) GetObjectID() uint64 {
	if m != nil {
		return m.ObjectID
	}
	return 0
}

func (m *AccessRightList) GetGroupPermissions() map[string]*PermissionSet {
	if m != nil {
		return m.GroupPermissions
	}
	return nil
}

func (m *AccessRightList) GetUserPermissions() map[string]*PermissionSet {
	if m != nil {
		return m.UserPermissions
	}
	return nil
}

func (m *AccessRightList) GetEffectivePermissions() *PermissionSet {
	if m != nil {
		return m.EffectivePermissions
	}
	return nil
}

type ResolveResponse struct {
	AccessRightList *AccessRightList `protobuf:"bytes,1,opt,name=AccessRightList" json:"AccessRightList,omitempty"`
	User            *auth.User       `protobuf:"bytes,2,opt,name=User" json:"User,omitempty"`
}

func (m *ResolveResponse) Reset()                    { *m = ResolveResponse{} }
func (m *ResolveResponse) String() string            { return proto.CompactTextString(m) }
func (*ResolveResponse) ProtoMessage()               {}
func (*ResolveResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ResolveResponse) GetAccessRightList() *AccessRightList {
	if m != nil {
		return m.AccessRightList
	}
	return nil
}

func (m *ResolveResponse) GetUser() *auth.User {
	if m != nil {
		return m.User
	}
	return nil
}

type IDGrantRequest struct {
	ID      uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	GroupID string `protobuf:"bytes,2,opt,name=GroupID" json:"GroupID,omitempty"`
	UserID  string `protobuf:"bytes,3,opt,name=UserID" json:"UserID,omitempty"`
	Read    bool   `protobuf:"varint,4,opt,name=Read" json:"Read,omitempty"`
	Write   bool   `protobuf:"varint,5,opt,name=Write" json:"Write,omitempty"`
}

func (m *IDGrantRequest) Reset()                    { *m = IDGrantRequest{} }
func (m *IDGrantRequest) String() string            { return proto.CompactTextString(m) }
func (*IDGrantRequest) ProtoMessage()               {}
func (*IDGrantRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *IDGrantRequest) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *IDGrantRequest) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

func (m *IDGrantRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *IDGrantRequest) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *IDGrantRequest) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

type ResolveRequest struct {
	UserID      string       `protobuf:"bytes,1,opt,name=UserID" json:"UserID,omitempty"`
	AuthRequest *AuthRequest `protobuf:"bytes,2,opt,name=AuthRequest" json:"AuthRequest,omitempty"`
}

func (m *ResolveRequest) Reset()                    { *m = ResolveRequest{} }
func (m *ResolveRequest) String() string            { return proto.CompactTextString(m) }
func (*ResolveRequest) ProtoMessage()               {}
func (*ResolveRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ResolveRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *ResolveRequest) GetAuthRequest() *AuthRequest {
	if m != nil {
		return m.AuthRequest
	}
	return nil
}

// ask for access
type AllAccessRequest struct {
	ObjectType OBJECTTYPE `protobuf:"varint,1,opt,name=ObjectType,enum=objectauth.OBJECTTYPE" json:"ObjectType,omitempty"`
	ServiceID  string     `protobuf:"bytes,2,opt,name=ServiceID" json:"ServiceID,omitempty"`
}

func (m *AllAccessRequest) Reset()                    { *m = AllAccessRequest{} }
func (m *AllAccessRequest) String() string            { return proto.CompactTextString(m) }
func (*AllAccessRequest) ProtoMessage()               {}
func (*AllAccessRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *AllAccessRequest) GetObjectType() OBJECTTYPE {
	if m != nil {
		return m.ObjectType
	}
	return OBJECTTYPE_UNDEFINED
}

func (m *AllAccessRequest) GetServiceID() string {
	if m != nil {
		return m.ServiceID
	}
	return ""
}

// reply to "allaccess"
type AllAccessResponse struct {
	Granted bool `protobuf:"varint,1,opt,name=Granted" json:"Granted,omitempty"`
}

func (m *AllAccessResponse) Reset()                    { *m = AllAccessResponse{} }
func (m *AllAccessResponse) String() string            { return proto.CompactTextString(m) }
func (*AllAccessResponse) ProtoMessage()               {}
func (*AllAccessResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *AllAccessResponse) GetGranted() bool {
	if m != nil {
		return m.Granted
	}
	return false
}

// grant "allaccess"
type GrantAllAccessRequest struct {
	ObjectType     OBJECTTYPE `protobuf:"varint,1,opt,name=ObjectType,enum=objectauth.OBJECTTYPE" json:"ObjectType,omitempty"`
	CallingService string     `protobuf:"bytes,2,opt,name=CallingService" json:"CallingService,omitempty"`
	SubjectService string     `protobuf:"bytes,3,opt,name=SubjectService" json:"SubjectService,omitempty"`
}

func (m *GrantAllAccessRequest) Reset()                    { *m = GrantAllAccessRequest{} }
func (m *GrantAllAccessRequest) String() string            { return proto.CompactTextString(m) }
func (*GrantAllAccessRequest) ProtoMessage()               {}
func (*GrantAllAccessRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *GrantAllAccessRequest) GetObjectType() OBJECTTYPE {
	if m != nil {
		return m.ObjectType
	}
	return OBJECTTYPE_UNDEFINED
}

func (m *GrantAllAccessRequest) GetCallingService() string {
	if m != nil {
		return m.CallingService
	}
	return ""
}

func (m *GrantAllAccessRequest) GetSubjectService() string {
	if m != nil {
		return m.SubjectService
	}
	return ""
}

// database object to save "allaccess"
type ServiceAccess struct {
	ID             uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	CallingService string `protobuf:"bytes,2,opt,name=CallingService" json:"CallingService,omitempty"`
	SubjectService string `protobuf:"bytes,3,opt,name=SubjectService" json:"SubjectService,omitempty"`
	CreatedBy      string `protobuf:"bytes,4,opt,name=CreatedBy" json:"CreatedBy,omitempty"`
	Created        uint32 `protobuf:"varint,5,opt,name=Created" json:"Created,omitempty"`
}

func (m *ServiceAccess) Reset()                    { *m = ServiceAccess{} }
func (m *ServiceAccess) String() string            { return proto.CompactTextString(m) }
func (*ServiceAccess) ProtoMessage()               {}
func (*ServiceAccess) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *ServiceAccess) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ServiceAccess) GetCallingService() string {
	if m != nil {
		return m.CallingService
	}
	return ""
}

func (m *ServiceAccess) GetSubjectService() string {
	if m != nil {
		return m.SubjectService
	}
	return ""
}

func (m *ServiceAccess) GetCreatedBy() string {
	if m != nil {
		return m.CreatedBy
	}
	return ""
}

func (m *ServiceAccess) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

func init() {
	proto.RegisterType((*GroupToComposite)(nil), "objectauth.GroupToComposite")
	proto.RegisterType((*UserToObject)(nil), "objectauth.UserToObject")
	proto.RegisterType((*GroupToObject)(nil), "objectauth.GroupToObject")
	proto.RegisterType((*AuthRequest)(nil), "objectauth.AuthRequest")
	proto.RegisterType((*AuthResponse)(nil), "objectauth.AuthResponse")
	proto.RegisterType((*ObjectType)(nil), "objectauth.ObjectType")
	proto.RegisterType((*ObjectIDList)(nil), "objectauth.ObjectIDList")
	proto.RegisterType((*GrantUserRequest)(nil), "objectauth.GrantUserRequest")
	proto.RegisterType((*GrantGroupRequest)(nil), "objectauth.GrantGroupRequest")
	proto.RegisterType((*PermissionSet)(nil), "objectauth.PermissionSet")
	proto.RegisterType((*AccessRightList)(nil), "objectauth.AccessRightList")
	proto.RegisterType((*ResolveResponse)(nil), "objectauth.ResolveResponse")
	proto.RegisterType((*IDGrantRequest)(nil), "objectauth.IDGrantRequest")
	proto.RegisterType((*ResolveRequest)(nil), "objectauth.ResolveRequest")
	proto.RegisterType((*AllAccessRequest)(nil), "objectauth.AllAccessRequest")
	proto.RegisterType((*AllAccessResponse)(nil), "objectauth.AllAccessResponse")
	proto.RegisterType((*GrantAllAccessRequest)(nil), "objectauth.GrantAllAccessRequest")
	proto.RegisterType((*ServiceAccess)(nil), "objectauth.ServiceAccess")
	proto.RegisterEnum("objectauth.OBJECTTYPE", OBJECTTYPE_name, OBJECTTYPE_value)
	proto.RegisterEnum("objectauth.COMPOSITETYPE", COMPOSITETYPE_name, COMPOSITETYPE_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ObjectAuthService service

type ObjectAuthServiceClient interface {
	//
	// check if a given service has got access to all such objects in a given service
	// for example: "Does h2gproxy have access to all users? -> no"
	// for example: "Does htmlserver (if called by h2gproxy) have access to all users? -> yes"
	AllowAllServiceAccess(ctx context.Context, in *AllAccessRequest, opts ...grpc.CallOption) (*AllAccessResponse, error)
	// allow a service to access all objects
	GrantAllServiceAccess(ctx context.Context, in *GrantAllAccessRequest, opts ...grpc.CallOption) (*common.Void, error)
	// ask if calling user has access to an object
	AskObjectAccess(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*AuthResponse, error)
	// get all objects (of a given type) the current user has access to
	AvailableObjects(ctx context.Context, in *ObjectType, opts ...grpc.CallOption) (*ObjectIDList, error)
	// grant access to a user. Currently this call is privileged for root users only
	GrantToUser(ctx context.Context, in *GrantUserRequest, opts ...grpc.CallOption) (*common.Void, error)
	// grant access to a group. Currently this call is privileged for root users only
	GrantToGroup(ctx context.Context, in *GrantGroupRequest, opts ...grpc.CallOption) (*common.Void, error)
	// grant access to me. Currently this call is privileged for root users only. Leave the userid field to 0
	GrantToMe(ctx context.Context, in *GrantUserRequest, opts ...grpc.CallOption) (*common.Void, error)
	// get acessrights for calling user for a specific object
	GetRights(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*AccessRightList, error)
	// give access to a sourcecode repository, its proto and its artefact
	GrantToSoftware(ctx context.Context, in *IDGrantRequest, opts ...grpc.CallOption) (*common.Void, error)
	// privileged for admins - get permissions for a particular user (to check permissions)
	ResolveForUser(ctx context.Context, in *ResolveRequest, opts ...grpc.CallOption) (*ResolveResponse, error)
}

type objectAuthServiceClient struct {
	cc *grpc.ClientConn
}

func NewObjectAuthServiceClient(cc *grpc.ClientConn) ObjectAuthServiceClient {
	return &objectAuthServiceClient{cc}
}

func (c *objectAuthServiceClient) AllowAllServiceAccess(ctx context.Context, in *AllAccessRequest, opts ...grpc.CallOption) (*AllAccessResponse, error) {
	out := new(AllAccessResponse)
	err := grpc.Invoke(ctx, "/objectauth.ObjectAuthService/AllowAllServiceAccess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAuthServiceClient) GrantAllServiceAccess(ctx context.Context, in *GrantAllAccessRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/objectauth.ObjectAuthService/GrantAllServiceAccess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAuthServiceClient) AskObjectAccess(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*AuthResponse, error) {
	out := new(AuthResponse)
	err := grpc.Invoke(ctx, "/objectauth.ObjectAuthService/AskObjectAccess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAuthServiceClient) AvailableObjects(ctx context.Context, in *ObjectType, opts ...grpc.CallOption) (*ObjectIDList, error) {
	out := new(ObjectIDList)
	err := grpc.Invoke(ctx, "/objectauth.ObjectAuthService/AvailableObjects", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAuthServiceClient) GrantToUser(ctx context.Context, in *GrantUserRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/objectauth.ObjectAuthService/GrantToUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAuthServiceClient) GrantToGroup(ctx context.Context, in *GrantGroupRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/objectauth.ObjectAuthService/GrantToGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAuthServiceClient) GrantToMe(ctx context.Context, in *GrantUserRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/objectauth.ObjectAuthService/GrantToMe", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAuthServiceClient) GetRights(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*AccessRightList, error) {
	out := new(AccessRightList)
	err := grpc.Invoke(ctx, "/objectauth.ObjectAuthService/GetRights", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAuthServiceClient) GrantToSoftware(ctx context.Context, in *IDGrantRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/objectauth.ObjectAuthService/GrantToSoftware", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *objectAuthServiceClient) ResolveForUser(ctx context.Context, in *ResolveRequest, opts ...grpc.CallOption) (*ResolveResponse, error) {
	out := new(ResolveResponse)
	err := grpc.Invoke(ctx, "/objectauth.ObjectAuthService/ResolveForUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ObjectAuthService service

type ObjectAuthServiceServer interface {
	//
	// check if a given service has got access to all such objects in a given service
	// for example: "Does h2gproxy have access to all users? -> no"
	// for example: "Does htmlserver (if called by h2gproxy) have access to all users? -> yes"
	AllowAllServiceAccess(context.Context, *AllAccessRequest) (*AllAccessResponse, error)
	// allow a service to access all objects
	GrantAllServiceAccess(context.Context, *GrantAllAccessRequest) (*common.Void, error)
	// ask if calling user has access to an object
	AskObjectAccess(context.Context, *AuthRequest) (*AuthResponse, error)
	// get all objects (of a given type) the current user has access to
	AvailableObjects(context.Context, *ObjectType) (*ObjectIDList, error)
	// grant access to a user. Currently this call is privileged for root users only
	GrantToUser(context.Context, *GrantUserRequest) (*common.Void, error)
	// grant access to a group. Currently this call is privileged for root users only
	GrantToGroup(context.Context, *GrantGroupRequest) (*common.Void, error)
	// grant access to me. Currently this call is privileged for root users only. Leave the userid field to 0
	GrantToMe(context.Context, *GrantUserRequest) (*common.Void, error)
	// get acessrights for calling user for a specific object
	GetRights(context.Context, *AuthRequest) (*AccessRightList, error)
	// give access to a sourcecode repository, its proto and its artefact
	GrantToSoftware(context.Context, *IDGrantRequest) (*common.Void, error)
	// privileged for admins - get permissions for a particular user (to check permissions)
	ResolveForUser(context.Context, *ResolveRequest) (*ResolveResponse, error)
}

func RegisterObjectAuthServiceServer(s *grpc.Server, srv ObjectAuthServiceServer) {
	s.RegisterService(&_ObjectAuthService_serviceDesc, srv)
}

func _ObjectAuthService_AllowAllServiceAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAuthServiceServer).AllowAllServiceAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectauth.ObjectAuthService/AllowAllServiceAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAuthServiceServer).AllowAllServiceAccess(ctx, req.(*AllAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAuthService_GrantAllServiceAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GrantAllAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAuthServiceServer).GrantAllServiceAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectauth.ObjectAuthService/GrantAllServiceAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAuthServiceServer).GrantAllServiceAccess(ctx, req.(*GrantAllAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAuthService_AskObjectAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAuthServiceServer).AskObjectAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectauth.ObjectAuthService/AskObjectAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAuthServiceServer).AskObjectAccess(ctx, req.(*AuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAuthService_AvailableObjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectType)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAuthServiceServer).AvailableObjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectauth.ObjectAuthService/AvailableObjects",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAuthServiceServer).AvailableObjects(ctx, req.(*ObjectType))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAuthService_GrantToUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GrantUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAuthServiceServer).GrantToUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectauth.ObjectAuthService/GrantToUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAuthServiceServer).GrantToUser(ctx, req.(*GrantUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAuthService_GrantToGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GrantGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAuthServiceServer).GrantToGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectauth.ObjectAuthService/GrantToGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAuthServiceServer).GrantToGroup(ctx, req.(*GrantGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAuthService_GrantToMe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GrantUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAuthServiceServer).GrantToMe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectauth.ObjectAuthService/GrantToMe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAuthServiceServer).GrantToMe(ctx, req.(*GrantUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAuthService_GetRights_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAuthServiceServer).GetRights(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectauth.ObjectAuthService/GetRights",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAuthServiceServer).GetRights(ctx, req.(*AuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAuthService_GrantToSoftware_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDGrantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAuthServiceServer).GrantToSoftware(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectauth.ObjectAuthService/GrantToSoftware",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAuthServiceServer).GrantToSoftware(ctx, req.(*IDGrantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ObjectAuthService_ResolveForUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ObjectAuthServiceServer).ResolveForUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/objectauth.ObjectAuthService/ResolveForUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ObjectAuthServiceServer).ResolveForUser(ctx, req.(*ResolveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ObjectAuthService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "objectauth.ObjectAuthService",
	HandlerType: (*ObjectAuthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AllowAllServiceAccess",
			Handler:    _ObjectAuthService_AllowAllServiceAccess_Handler,
		},
		{
			MethodName: "GrantAllServiceAccess",
			Handler:    _ObjectAuthService_GrantAllServiceAccess_Handler,
		},
		{
			MethodName: "AskObjectAccess",
			Handler:    _ObjectAuthService_AskObjectAccess_Handler,
		},
		{
			MethodName: "AvailableObjects",
			Handler:    _ObjectAuthService_AvailableObjects_Handler,
		},
		{
			MethodName: "GrantToUser",
			Handler:    _ObjectAuthService_GrantToUser_Handler,
		},
		{
			MethodName: "GrantToGroup",
			Handler:    _ObjectAuthService_GrantToGroup_Handler,
		},
		{
			MethodName: "GrantToMe",
			Handler:    _ObjectAuthService_GrantToMe_Handler,
		},
		{
			MethodName: "GetRights",
			Handler:    _ObjectAuthService_GetRights_Handler,
		},
		{
			MethodName: "GrantToSoftware",
			Handler:    _ObjectAuthService_GrantToSoftware_Handler,
		},
		{
			MethodName: "ResolveForUser",
			Handler:    _ObjectAuthService_ResolveForUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/golang.conradwood.net/apis/objectauth/objectauth.proto",
}

func init() {
	proto.RegisterFile("protos/golang.conradwood.net/apis/objectauth/objectauth.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1155 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xcc, 0x58, 0x5f, 0x6f, 0xe3, 0x44,
	0x10, 0xc7, 0xf9, 0xd7, 0x64, 0xf2, 0xa7, 0xee, 0xaa, 0x57, 0x4c, 0xe8, 0xa1, 0x60, 0xe9, 0x50,
	0x54, 0x41, 0xca, 0x15, 0x09, 0x28, 0x15, 0x0f, 0x6e, 0x9c, 0x96, 0x20, 0xfa, 0x47, 0x4e, 0xee,
	0x10, 0x27, 0x1d, 0xc8, 0x4d, 0xb6, 0xa9, 0x39, 0xd7, 0x1b, 0xec, 0x4d, 0x7b, 0x95, 0x78, 0xe3,
	0x85, 0x6f, 0xc1, 0x23, 0x6f, 0x7c, 0x01, 0xbe, 0x07, 0x12, 0x5f, 0x05, 0x09, 0x09, 0x79, 0xbd,
	0x8e, 0x77, 0x9d, 0x34, 0xe5, 0xee, 0xda, 0xd3, 0x3d, 0xc5, 0x33, 0xde, 0x99, 0xdf, 0xcc, 0xf8,
	0x37, 0xb3, 0xbb, 0x81, 0x2f, 0xc7, 0x3e, 0xa1, 0x24, 0xd8, 0x1c, 0x11, 0xd7, 0xf6, 0x46, 0xad,
	0x01, 0xf1, 0x7c, 0x7b, 0x78, 0x49, 0xc8, 0xb0, 0xe5, 0x61, 0xba, 0x69, 0x8f, 0x9d, 0x60, 0x93,
	0x9c, 0xfc, 0x88, 0x07, 0xd4, 0x9e, 0xd0, 0x33, 0xe1, 0xb1, 0xc5, 0xec, 0x10, 0x24, 0x9a, 0x7a,
	0x6b, 0x81, 0x8f, 0x01, 0x39, 0x3f, 0x27, 0x1e, 0xff, 0x89, 0x6c, 0xeb, 0x1b, 0x0b, 0xd6, 0x33,
	0xb4, 0x04, 0x47, 0xff, 0x25, 0x03, 0xea, 0xbe, 0x4f, 0x26, 0xe3, 0x3e, 0x69, 0x93, 0xf3, 0x31,
	0x09, 0x1c, 0x8a, 0x51, 0x0d, 0x32, 0x5d, 0x53, 0x53, 0x1a, 0x4a, 0x33, 0x67, 0x65, 0xba, 0x26,
	0xda, 0x06, 0x38, 0x62, 0xe1, 0xf4, 0xaf, 0xc6, 0x58, 0xcb, 0x34, 0x94, 0x66, 0x6d, 0xeb, 0x9d,
	0x96, 0x10, 0x73, 0xfb, 0xe8, 0xe0, 0xf8, 0xa8, 0xd7, 0xed, 0x77, 0xfa, 0xdf, 0x1d, 0x77, 0x2c,
	0x61, 0x31, 0xaa, 0x43, 0x31, 0x92, 0xba, 0xa6, 0x96, 0x65, 0x0e, 0xa7, 0x32, 0xd2, 0x60, 0x89,
	0x41, 0x77, 0x4d, 0x2d, 0xd7, 0x50, 0x9a, 0x25, 0x2b, 0x16, 0xd1, 0x1a, 0x14, 0x8c, 0x01, 0x75,
	0x2e, 0xb0, 0x96, 0x6f, 0x28, 0xcd, 0xa2, 0xc5, 0x25, 0x84, 0x20, 0x67, 0x61, 0x7b, 0xa8, 0x15,
	0x98, 0x96, 0x3d, 0xa3, 0x55, 0xc8, 0x7f, 0xeb, 0x3b, 0x14, 0x6b, 0x4b, 0x4c, 0x19, 0x09, 0xa1,
	0xef, 0xce, 0x73, 0x3c, 0x98, 0x50, 0xac, 0x15, 0x99, 0x3e, 0x16, 0x43, 0x1f, 0x8f, 0x1d, 0x7c,
	0xa9, 0x95, 0x22, 0x1f, 0xe1, 0xb3, 0xfe, 0x8f, 0x02, 0x95, 0x47, 0x01, 0xf6, 0xfb, 0x24, 0x0a,
	0x6e, 0xa6, 0x02, 0x9f, 0xce, 0xa9, 0xc0, 0x9a, 0x58, 0x81, 0xa3, 0xdd, 0xaf, 0x3b, 0xed, 0xfe,
	0x0b, 0xa5, 0xbf, 0x06, 0x85, 0x10, 0x73, 0x9a, 0x3d, 0x97, 0x5e, 0x7b, 0xf2, 0xff, 0x2a, 0x50,
	0xe5, 0x14, 0x78, 0x8d, 0xd9, 0xbf, 0x39, 0x1f, 0xdf, 0x86, 0xb2, 0x31, 0xa1, 0x67, 0x16, 0xfe,
	0x69, 0x82, 0x03, 0x9a, 0x4a, 0x56, 0x79, 0xa9, 0x64, 0x33, 0x72, 0xb2, 0x3a, 0x86, 0x4a, 0x04,
	0x11, 0x8c, 0x89, 0x17, 0xe0, 0x28, 0x79, 0xdb, 0xa3, 0x78, 0xc8, 0x00, 0x8a, 0x56, 0x2c, 0xa2,
	0x1d, 0x28, 0x1f, 0x63, 0xff, 0xdc, 0x09, 0x02, 0x87, 0x78, 0x01, 0x73, 0x54, 0x96, 0x7b, 0x2d,
	0x79, 0xdd, 0xc3, 0xd4, 0x12, 0x57, 0xeb, 0xa6, 0x18, 0xfa, 0xcb, 0x26, 0xa2, 0x7f, 0x08, 0x95,
	0x38, 0xf0, 0x6f, 0x9c, 0x80, 0xa2, 0x75, 0x28, 0xc5, 0x72, 0xa0, 0x29, 0x8d, 0x6c, 0x33, 0x67,
	0x25, 0x0a, 0xfd, 0x2f, 0x25, 0x1c, 0x20, 0xb6, 0x47, 0x43, 0xf6, 0xde, 0x61, 0x0d, 0x85, 0x76,
	0xc9, 0x4a, 0xed, 0x12, 0xd3, 0x22, 0x37, 0x8f, 0x16, 0xf9, 0x6b, 0x68, 0x51, 0x98, 0x4f, 0x8b,
	0x25, 0x81, 0x16, 0x7f, 0x2b, 0xb0, 0xc2, 0x12, 0x63, 0xbc, 0xbc, 0xcb, 0xcc, 0x84, 0x56, 0xc8,
	0xca, 0xad, 0x70, 0x57, 0xb9, 0x8d, 0xa0, 0x2a, 0xd1, 0x68, 0x0a, 0xa4, 0xcc, 0x03, 0xca, 0x5c,
	0x03, 0x94, 0x9d, 0x0f, 0x94, 0x13, 0x80, 0xfe, 0xc8, 0xc1, 0xb2, 0x31, 0x18, 0xe0, 0x20, 0xb0,
	0x9c, 0xd1, 0x19, 0x65, 0x7c, 0xba, 0x8b, 0x12, 0x3e, 0xe5, 0xbb, 0x98, 0xd8, 0x3b, 0xd9, 0x46,
	0xb6, 0x59, 0xde, 0x7a, 0x28, 0x7a, 0x4e, 0x85, 0xd2, 0x4a, 0xdb, 0x74, 0x3c, 0xea, 0x5f, 0x59,
	0x33, 0xae, 0xd0, 0x13, 0x58, 0x0e, 0xd9, 0x26, 0x7a, 0xcf, 0x31, 0xef, 0x1f, 0x2f, 0xf2, 0x9e,
	0x32, 0x89, 0x9c, 0xa7, 0x1d, 0xa1, 0x03, 0x58, 0xed, 0x9c, 0x9e, 0x62, 0x36, 0xe3, 0x44, 0x80,
	0xfc, 0x4d, 0xad, 0x3f, 0xd7, 0xac, 0xfe, 0x3d, 0xdc, 0x9b, 0x9b, 0x15, 0x52, 0x21, 0xfb, 0x0c,
	0x5f, 0xb1, 0x7a, 0x97, 0xac, 0xf0, 0x11, 0x6d, 0x42, 0xfe, 0xc2, 0x76, 0x27, 0xf8, 0xe6, 0x29,
	0x13, 0xad, 0xfb, 0x22, 0xf3, 0xb9, 0x52, 0x7f, 0x0a, 0xab, 0xf3, 0xf2, 0xba, 0x25, 0xf7, 0xfa,
	0x73, 0x58, 0xb6, 0x70, 0x40, 0xdc, 0x0b, 0x3c, 0x1d, 0x96, 0x9d, 0x19, 0x0a, 0x31, 0x94, 0xf2,
	0xd6, 0xbb, 0x0b, 0x8a, 0x6f, 0xcd, 0xd0, 0xee, 0x3d, 0xc8, 0x85, 0x81, 0xf3, 0x68, 0xa0, 0xc5,
	0xac, 0xd8, 0xd0, 0x62, 0x7a, 0xfd, 0x67, 0xa8, 0x75, 0x4d, 0xd6, 0xf0, 0x71, 0xaf, 0xa7, 0xb7,
	0x41, 0xa1, 0x4f, 0x33, 0x33, 0x5b, 0xd6, 0xab, 0xcd, 0x26, 0x7d, 0x00, 0xb5, 0x69, 0xde, 0x11,
	0x7a, 0xe2, 0x53, 0x91, 0x7c, 0x6e, 0x4b, 0xdb, 0x15, 0x4f, 0xe7, 0x6d, 0xa9, 0x14, 0xc9, 0x6b,
	0x4b, 0x5c, 0xab, 0x9f, 0x81, 0x6a, 0xb8, 0x2e, 0x2f, 0xcc, 0x2b, 0x0e, 0xb4, 0x75, 0x28, 0xf5,
	0xb0, 0x7f, 0xe1, 0x0c, 0xf0, 0xb4, 0x1c, 0x89, 0x42, 0xff, 0x08, 0x56, 0x04, 0xa4, 0x9b, 0x76,
	0x3d, 0xfd, 0x37, 0x25, 0x64, 0xad, 0xed, 0xd1, 0x5b, 0x0b, 0xef, 0x03, 0xa8, 0xb5, 0x6d, 0xd7,
	0x75, 0xbc, 0x11, 0x0f, 0x8a, 0xc7, 0x98, 0xd2, 0x86, 0xeb, 0x7a, 0x13, 0x66, 0x16, 0xaf, 0x8b,
	0xbe, 0x60, 0x4a, 0xab, 0xff, 0xae, 0x40, 0x95, 0x3f, 0x47, 0x01, 0xce, 0xb0, 0xe3, 0x96, 0x11,
	0xc3, 0x02, 0xb7, 0x7d, 0x6c, 0x53, 0x3c, 0xdc, 0xbd, 0xe2, 0x47, 0xa4, 0x44, 0x11, 0xd6, 0x92,
	0x0b, 0x8c, 0x47, 0x55, 0x2b, 0x16, 0x37, 0x7e, 0x55, 0x00, 0x92, 0xa2, 0xa0, 0x2a, 0x94, 0x1e,
	0x1d, 0x9a, 0x9d, 0xbd, 0xee, 0x61, 0xc7, 0x54, 0xdf, 0x42, 0x65, 0x58, 0xe2, 0x00, 0xaa, 0x82,
	0x2a, 0x50, 0x34, 0x7c, 0x8a, 0x4f, 0xed, 0x01, 0x55, 0x33, 0x68, 0x05, 0xaa, 0xfb, 0x0e, 0xb5,
	0x30, 0xbb, 0x04, 0x10, 0xff, 0x4a, 0xcd, 0xa2, 0x55, 0x50, 0x7b, 0x8e, 0x37, 0x72, 0xbc, 0x51,
	0xdb, 0xa6, 0x07, 0x64, 0x38, 0x71, 0xb1, 0x9a, 0x43, 0x25, 0xc8, 0x1f, 0x87, 0x97, 0x07, 0x35,
	0x8f, 0x00, 0x0a, 0x26, 0x39, 0xb7, 0x1d, 0x4f, 0x2d, 0x20, 0x35, 0x3a, 0x43, 0x1b, 0xe3, 0xf1,
	0x9e, 0x6b, 0x8f, 0x02, 0x75, 0x69, 0xe3, 0x21, 0x54, 0xa5, 0x9b, 0x01, 0x42, 0x50, 0x0b, 0x15,
	0x3f, 0x88, 0x11, 0x55, 0xa0, 0xd8, 0x23, 0xa7, 0xf4, 0xd2, 0xf6, 0xb1, 0xaa, 0x6c, 0xfd, 0x99,
	0x87, 0x95, 0xe8, 0x33, 0x86, 0xc4, 0x8d, 0x6b, 0xd1, 0x87, 0x7b, 0x86, 0xeb, 0x92, 0x4b, 0xc3,
	0x75, 0xe5, 0x8f, 0xb0, 0x2e, 0xf1, 0x3e, 0x45, 0x9e, 0xfa, 0xfd, 0x6b, 0xde, 0x72, 0x3e, 0x7e,
	0x95, 0x90, 0x4e, 0xf6, 0xfa, 0xbe, 0x68, 0x37, 0x97, 0x97, 0xf5, 0x4a, 0x8b, 0x5f, 0xb9, 0x1e,
	0x13, 0x67, 0x88, 0x4c, 0x58, 0x36, 0x82, 0x67, 0x3c, 0xee, 0xc8, 0xc7, 0x75, 0x1d, 0x59, 0xd7,
	0x66, 0x5f, 0xf0, 0x78, 0x4c, 0x50, 0x8d, 0x0b, 0xdb, 0x71, 0xed, 0x13, 0x17, 0x47, 0xbe, 0x02,
	0x24, 0x73, 0x7d, 0xca, 0x6f, 0xd9, 0x8b, 0x74, 0x5c, 0xdb, 0x86, 0x32, 0x0b, 0xb9, 0x4f, 0xc2,
	0xaf, 0x21, 0x57, 0x28, 0x7d, 0x50, 0x4b, 0xa5, 0xb1, 0x03, 0x15, 0x6e, 0xca, 0x06, 0x1b, 0xba,
	0x3f, 0x63, 0x2b, 0x9e, 0x85, 0x52, 0xc6, 0x9f, 0x41, 0x89, 0x1b, 0x1f, 0xe0, 0x17, 0x42, 0x35,
	0xa0, 0xb4, 0x8f, 0x29, 0x1b, 0xd4, 0x0b, 0xca, 0xb6, 0x68, 0xd8, 0xa3, 0x1d, 0x58, 0xe6, 0xd8,
	0x31, 0x95, 0x50, 0x5d, 0x5c, 0x2f, 0x0f, 0xf6, 0x14, 0x7e, 0x77, 0x3a, 0x7a, 0xf7, 0x88, 0xcf,
	0x6a, 0x26, 0xd9, 0xca, 0x63, 0x59, 0x8e, 0x23, 0xb5, 0x55, 0xed, 0x1e, 0xc2, 0x03, 0x0f, 0x53,
	0xf1, 0xe2, 0xcd, 0xaf, 0xe2, 0xe1, 0xdd, 0x5b, 0x30, 0x7c, 0xf2, 0xe0, 0x7f, 0xfd, 0x2d, 0x70,
	0x52, 0x60, 0x97, 0xf4, 0x4f, 0xfe, 0x0b, 0x00, 0x00, 0xff, 0xff, 0xa1, 0x2a, 0x8e, 0x11, 0x4d,
	0x10, 0x00, 0x00,
}
